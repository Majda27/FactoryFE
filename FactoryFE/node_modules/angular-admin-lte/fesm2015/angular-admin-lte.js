import { Title } from '@angular/platform-browser';
import { distinctUntilChanged, pluck } from 'rxjs/operators';
import { NavigationEnd, PRIMARY_OUTLET, Router, RouterModule, NavigationStart } from '@angular/router';
import { BehaviorSubject, Subject } from 'rxjs';
import { NgControl, FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { Injectable, Component, Input, ChangeDetectorRef, NgModule, ChangeDetectionStrategy, ViewChild, ElementRef, ContentChild, NgZone, Renderer2, Directive, Output, EventEmitter, ViewChildren, InjectionToken, Optional, SkipSelf, ContentChildren, ViewContainerRef, HostListener } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class RoutingService {
    /**
     * \@method constructor
     * @param {?} router [description]
     */
    constructor(router) {
        this.router = router;
        this.onChange = new BehaviorSubject(undefined);
        this.events = new BehaviorSubject(undefined);
        this.init();
    }
    /**
     * [createUrl description]
     * \@method createUrl
     * @private
     * @param {?} route [description]
     * @return {?} [description]
     */
    static createUrl(route) {
        /** @type {?} */
        const url = route.url.map((/**
         * @param {?} urlSegment
         * @return {?}
         */
        urlSegment => urlSegment.toString())).join('/');
        return url;
    }
    /**
     * [isChildrenSelfRoute description]
     * \@method isChildrenSelfRoute
     * @private
     * @param {?} route [description]
     * @return {?} [description]
     */
    static isChildrenSelfRoute(route) {
        route.routeConfig.children.forEach((/**
         * @param {?} child
         * @return {?}
         */
        child => {
            if (child.path === '' && (child.component || child.loadChildren)) {
                return true;
            }
        }));
        return false;
    }
    /**
     * [createBreadcrumb description]
     * \@method createBreadcrumb
     * @private
     * @param {?} route [description]
     * @param {?} url   [description]
     * @return {?} [description]
     */
    static createBreadcrumb(route, url) {
        /** @type {?} */
        let isUrl = true;
        if (route.children.length !== 0 && route.firstChild.routeConfig.path) {
            if (url !== '/' && !route.routeConfig.loadChildren && !route.routeConfig.component && !RoutingService.isChildrenSelfRoute(route)) {
                isUrl = false;
            }
        }
        return {
            data: route.data,
            params: route.params,
            url: isUrl ? url : null
        };
    }
    /**
     * [init description]
     * \@method init
     * @private
     * @return {?}
     */
    init() {
        this.router.events.subscribe((/**
         * @param {?} routeEvent
         * @return {?}
         */
        routeEvent => {
            // https://github.com/angular/angular/issues/17473: event not fired anymore on load for routed component.
            if (routeEvent instanceof NavigationEnd) {
                this.events.next(routeEvent);
                /** @type {?} */
                let route = this.router.routerState.root.snapshot;
                /** @type {?} */
                let tmpUrl = '';
                /** @type {?} */
                let url = '';
                /** @type {?} */
                let rootRoot = true;
                /** @type {?} */
                const paths = [];
                while (route.children.length) {
                    route = route.firstChild;
                    tmpUrl = `/${RoutingService.createUrl(route)}`;
                    if (route.outlet !== PRIMARY_OUTLET || (!route.routeConfig.path && !rootRoot)) {
                        continue;
                    }
                    rootRoot = false;
                    if (route.params || route.data) {
                        for (const key in route.params) {
                            if (!key) {
                                continue;
                            }
                            if (route.data['title']) {
                                route.data['title'] = route.data['title'].replace(`:${key}`, route.params[key]);
                                route.data['title'] = route.data['title'].replace(`:${key}`, route.params[key]);
                            }
                            if (route.data['breadcrumbs']) {
                                route.data['breadcrumbs'] = route.data['breadcrumbs'].replace(`:${key}`, route.params[key]);
                            }
                            if (route.data['description']) {
                                route.data['description'] = route.data['description'].replace(`:${key}`, route.params[key]);
                            }
                        }
                    }
                    if (tmpUrl === '/') {
                        paths.push(RoutingService.createBreadcrumb(route, tmpUrl));
                    }
                    else {
                        url += tmpUrl;
                        paths.push(RoutingService.createBreadcrumb(route, url));
                    }
                }
                this.onChange.next(paths);
            }
        }));
    }
}
RoutingService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RoutingService.ctorParameters = () => [
    { type: Router }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class BreadcrumbsComponent {
    /**
     * \@method constructor
     * @param {?} routingService [description]
     * @param {?} changeDetectorRef [description]
     */
    constructor(routingService, changeDetectorRef) {
        this.routingService = routingService;
        this.changeDetectorRef = changeDetectorRef;
        this.homeIcon = 'fa fa-home';
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        this.subscription = this.routingService.onChange.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        value => {
            this.breadcrumbs = value;
        }));
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
BreadcrumbsComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-breadcrumbs',
                template: "<ol class=\"breadcrumb\">\n  <li *ngFor=\"let breadcrumb of breadcrumbs; let first = first; let last = last\" [class.active]=\"last || !breadcrumb.url\">\n    <a *ngIf=\"breadcrumb.url\" [routerLink]=\"breadcrumb.url\">\n      <i *ngIf=\"first\" ngClass=\"{{homeIcon}}\"></i>\n      <ng-template [ngIf]=\"breadcrumb.data.breadcrumbs\">{{breadcrumb.data.breadcrumbs}}</ng-template>\n      <ng-template [ngIf]=\"!breadcrumb.data.breadcrumbs\">{{breadcrumb.data.title}}</ng-template>\n    </a>\n    <ng-template [ngIf]=\"!breadcrumb.url\">\n      <i *ngIf=\"first\" ngClass=\"{{homeIcon}}\"></i>\n      <ng-template [ngIf]=\"breadcrumb.data.breadcrumbs\">{{breadcrumb.data.breadcrumbs}}</ng-template>\n      <ng-template [ngIf]=\"!breadcrumb.data.breadcrumbs\">{{breadcrumb.data.title}}</ng-template>\n    </ng-template>\n  </li>\n</ol>\n",
                styles: [".breadcrumb{float:right;background:0 0;margin-top:0;margin-bottom:0;font-size:12px;padding:7px 5px;position:absolute;top:15px;right:10px;border-radius:2px}.breadcrumb>li>a{color:#444;text-decoration:none;display:inline-block}.breadcrumb>li>a>.fa,.breadcrumb>li>a>.glyphicon,.breadcrumb>li>a>.ion{margin-right:5px}"]
            }] }
];
/** @nocollapse */
BreadcrumbsComponent.ctorParameters = () => [
    { type: RoutingService },
    { type: ChangeDetectorRef }
];
BreadcrumbsComponent.propDecorators = {
    homeIcon: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BreadcrumbsModule {
}
BreadcrumbsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule],
                exports: [BreadcrumbsComponent],
                declarations: [BreadcrumbsComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class LayoutStore {
    /**
     * \@method constructor
     * @param {?} layoutConfig [description]
     */
    constructor(layoutConfig) {
        this.initialLayoutState = {
            isSidebarLeftCollapsed: false,
            isSidebarLeftExpandOnOver: false,
            isSidebarLeftMouseOver: false,
            isSidebarLeftMini: true,
            sidebarRightSkin: 'dark',
            isSidebarRightCollapsed: true,
            isSidebarRightOverContent: true,
            layout: 'normal',
            sidebarLeftMenu: [],
            sidebarLeftMenuActiveUrl: '',
            skin: 'blue'
        };
        if (layoutConfig) {
            this.initialLayoutState = Object.assign(this.initialLayoutState, layoutConfig);
        }
        this._layoutState = new BehaviorSubject(this.initialLayoutState);
        this.layoutState = this._layoutState.asObservable();
    }
    /**
     * [windowInnerHeight description]
     * \@method windowInnerHeight
     * @return {?} [description]
     */
    get windowInnerHeight() {
        return (/** @type {?} */ (this.layoutState.pipe(pluck('windowInnerHeight'), distinctUntilChanged())));
    }
    /**
     * [windowInnerWidth description]
     * \@method windowInnerWidth
     * @return {?} [description]
     */
    get windowInnerWidth() {
        return (/** @type {?} */ (this.layoutState.pipe(pluck('windowInnerWidth'), distinctUntilChanged())));
    }
    /**
     * [isSidebarLeftCollapsed description]
     * @return {?} [description]
     */
    get isSidebarLeftCollapsed() {
        return (/** @type {?} */ (this.layoutState.pipe(pluck('isSidebarLeftCollapsed'), distinctUntilChanged())));
    }
    /**
     * [isSidebarLeftExpandOnOver description]
     * \@method isSidebarLeftExpandOnOver
     * @return {?} [description]
     */
    get isSidebarLeftExpandOnOver() {
        return (/** @type {?} */ (this.layoutState.pipe(pluck('isSidebarLeftExpandOnOver'), distinctUntilChanged())));
    }
    /**
     * [isSidebarLeftMouseOver description]
     * \@method isSidebarLeftMouseOver
     * @return {?} [description]
     */
    get isSidebarLeftMouseOver() {
        return (/** @type {?} */ (this.layoutState.pipe(pluck('isSidebarLeftMouseOver'), distinctUntilChanged())));
    }
    /**
     * [isSidebarLeftMini description]
     * \@method isSidebarLeftMini
     * @return {?} [description]
     */
    get isSidebarLeftMini() {
        return (/** @type {?} */ (this.layoutState.pipe(pluck('isSidebarLeftMini'), distinctUntilChanged())));
    }
    /**
     * [sidebarRightSkin description]
     * \@method sidebarRightSkin
     * @return {?} [description]
     */
    get sidebarRightSkin() {
        return (/** @type {?} */ (this.layoutState.pipe(pluck('sidebarRightSkin'), distinctUntilChanged())));
    }
    /**
     * [isSidebarRightCollapsed description]
     * @return {?} [description]
     */
    get isSidebarRightCollapsed() {
        return (/** @type {?} */ (this.layoutState.pipe(pluck('isSidebarRightCollapsed'), distinctUntilChanged())));
    }
    /**
     * [isSidebarRightOverContent description]
     * \@method isSidebarRightOverContent
     * @return {?} [description]
     */
    get isSidebarRightOverContent() {
        return (/** @type {?} */ (this.layoutState.pipe(pluck('isSidebarRightOverContent'), distinctUntilChanged())));
    }
    /**
     * [sidebarLeftMenu description]
     * \@method sidebarLeftMenu
     * @return {?} [description]
     */
    get sidebarLeftMenu() {
        return (/** @type {?} */ (this.layoutState.pipe(pluck('sidebarLeftMenu'), distinctUntilChanged())));
    }
    /**
     * [sidebarLeftMenuActiveUrl description]
     * \@method sidebarLeftMenuActiveUrl
     * @return {?} [description]
     */
    get sidebarLeftMenuActiveUrl() {
        return (/** @type {?} */ (this.layoutState.pipe(pluck('sidebarLeftMenuActiveUrl'), distinctUntilChanged())));
    }
    /**
     * [sidebarLeftElementHeight description]
     * \@method sidebarLeftElementHeight
     * @return {?} [description]
     */
    get sidebarLeftElementHeight() {
        return (/** @type {?} */ (this.layoutState.pipe(pluck('sidebarLeftElementHeight'), distinctUntilChanged())));
    }
    /**
     * [layoutType description]
     * \@method layoutType
     * @return {?} [description]
     */
    get layout() {
        return (/** @type {?} */ (this.layoutState.pipe(pluck('layout'), distinctUntilChanged())));
    }
    /**
     * [skin description]
     * \@method skin
     * @return {?} [description]
     */
    get skin() {
        return (/** @type {?} */ (this.layoutState.pipe(pluck('skin'), distinctUntilChanged())));
    }
    /**
     * [wrapperClasses description]
     * \@method wrapperClasses
     * @return {?} [description]
     */
    get wrapperClasses() {
        return (/** @type {?} */ (this.layoutState.pipe(pluck('wrapperClasses'), distinctUntilChanged())));
    }
    /**
     * [sidebarLeftCollapsed description]
     * \@method sidebarLeftCollapsed
     * @param {?=} value [description]
     * @return {?}
     */
    sidebarLeftCollapsed(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { isSidebarLeftCollapsed: value }));
    }
    /**
     * [sidebarLeftExpandOnOver description]
     * \@method sidebarLeftExpandOnOver
     * @param {?=} value [description]
     * @return {?}
     */
    sidebarLeftExpandOnOver(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { isSidebarLeftExpandOnOver: value }));
    }
    /**
     * [setSidebarLeftElementHeight description]
     * \@method setSidebarLeftElementHeight
     * @param {?} value [description]
     * @return {?}
     */
    setSidebarLeftElementHeight(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { sidebarLeftElementHeight: value }));
    }
    /**
     * [setSidebarRightSkin description]
     * \@method setSidebarRightSkin
     * @param {?=} value [description]
     * @return {?}
     */
    setSidebarRightSkin(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { sidebarRightSkin: value }));
    }
    /**
     * [sidebarLeftMouseOver description]
     * \@method sidebarLeftMouseOver
     * @param {?=} value [description]
     * @return {?}
     */
    sidebarLeftMouseOver(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { isSidebarLeftMouseOver: value }));
    }
    /**
     * [sidebarLeftMini description]
     * \@method sidebarLeftMini
     * @param {?=} value [description]
     * @return {?}
     */
    sidebarLeftMini(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { isSidebarLeftMini: value }));
    }
    /**
     * [sidebarRightCollapsed description]
     * \@method sidebarRightCollapsed
     * @param {?=} value [description]
     * @return {?}
     */
    sidebarRightCollapsed(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { isSidebarRightCollapsed: value }));
    }
    /**
     * [sidebarRightOverContent description]
     * \@method sidebarRightOverContent
     * @param {?=} value [description]
     * @return {?}
     */
    sidebarRightOverContent(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { isSidebarRightOverContent: value }));
    }
    /**
     * [setSidebarLeftMenu description]
     * \@method setSidebarLeftMenu
     * @param {?} value [description]
     * @return {?}
     */
    setSidebarLeftMenu(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { sidebarLeftMenu: value }));
    }
    /**
     * [setSidebarLeftMenuActiveUrl description]
     * \@method setSidebarLeftMenuActiveUrl
     * @param {?} value [description]
     * @return {?}
     */
    setSidebarLeftMenuActiveUrl(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { sidebarLeftMenuActiveUrl: value }));
    }
    /**
     * [setLayout description]
     * \@method setLayout
     * @param {?} value [description]
     * @return {?}
     */
    setLayout(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { layout: value }));
    }
    /**
     * [setSkin description]
     * \@method setSkin
     * @param {?} value [description]
     * @return {?}
     */
    setSkin(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { skin: value }));
    }
    /**
     * [setWrapperClasses description]
     * \@method setWrapperClasses
     * @param {?} value [description]
     * @return {?}
     */
    setWrapperClasses(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { wrapperClasses: value }));
    }
    /**
     * [setWindowInnerHeight description]
     * \@method setWindowInnerHeight
     * @param {?} value [description]
     * @return {?}
     */
    setWindowInnerHeight(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { windowInnerHeight: value }));
    }
    /**
     * [setWindowInnerWidth description]
     * \@method setWindowInnerWidth
     * @param {?} value [description]
     * @return {?}
     */
    setWindowInnerWidth(value) {
        this._layoutState.next(Object.assign(this._layoutState.value, { windowInnerWidth: value }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SidebarRightService {
    /**
     * [scrollHeight description]
     * \@method scrollHeight
     * @return {?} [description]
     */
    get scrollHeight() {
        return this.elementRef ? this.elementRef.nativeElement.scrollHeight : null;
    }
}
SidebarRightService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HeaderService {
    /**
     * [offsetHeight description]
     * \@method offsetHeight
     * @return {?} [description]
     */
    get offsetHeight() {
        return this.elementRef.nativeElement.offsetHeight;
    }
}
HeaderService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FooterService {
    /**
     * [offsetHeight description]
     * \@method offsetHeight
     * @return {?} [description]
     */
    get offsetHeight() {
        return this.elementRef.nativeElement.offsetHeight;
    }
}
FooterService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * [throttle description]
 * \@method throttle
 * @param {?} callback [description]
 * @param {?} delay    [description]
 * @return {?} [description]
 */
function throttle(callback, delay) {
    /** @type {?} */
    let timeout = null;
    return (/**
     * @param {...?} args
     * @return {?}
     */
    (...args) => {
        if (!timeout) {
            timeout = setTimeout((/**
             * @return {?}
             */
            () => {
                callback.call(this, ...args);
                timeout = null;
            }), delay);
        }
    });
}
/**
 * [removeSubscriptions description]
 * \@method removeSubscriptions
 * @param {?} subscriptions
 * @return {?}
 */
function removeSubscriptions(subscriptions) {
    if (subscriptions) {
        subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        (subscription) => {
            subscription.unsubscribe();
        }));
    }
    return [];
}
/**
 * [removeListeners description]
 * \@method removeListeners
 * @param {?} listeners
 * @return {?}
 */
function removeListeners(listeners) {
    if (listeners) {
        listeners.forEach((/**
         * @param {?} listener
         * @return {?}
         */
        (listener) => {
            listener();
        }));
    }
    return [];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentComponent {
    /**
     * \@method constructor
     * @param {?} layoutStore
     * @param {?} routingService
     * @param {?} titleService
     * @param {?} elementRef
     * @param {?} changeDetectorRef
     * @param {?} sidebarRightService
     * @param {?} headerService
     * @param {?} footerService
     * @param {?} router
     */
    constructor(layoutStore, routingService, titleService, elementRef, changeDetectorRef, sidebarRightService, headerService, footerService, router) {
        this.layoutStore = layoutStore;
        this.routingService = routingService;
        this.titleService = titleService;
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.sidebarRightService = sidebarRightService;
        this.headerService = headerService;
        this.footerService = footerService;
        this.router = router;
        this.subscriptions = [];
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        this.titleTag = this.titleService.getTitle();
        this.subscriptions.push(this.routingService.onChange.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            if (value && value[value.length - 1]) {
                this.titleService.setTitle(this.getTitle(value[value.length - 1].data['title']));
                this.header = value[value.length - 1].data['title'];
                this.description = value[value.length - 1].data['description'];
            }
            this.changeDetectorRef.markForCheck();
        })));
        this.subscriptions.push(this.router.events.subscribe((/**
         * @param {?} routeEvent
         * @return {?}
         */
        (routeEvent) => {
            if (routeEvent instanceof NavigationStart) {
                this.navigationEnd = false;
            }
            if (routeEvent instanceof NavigationEnd) {
                this.navigationEnd = true;
                this.setContentMinHeight();
            }
        })));
        this.subscriptions.push(this.layoutStore.sidebarLeftElementHeight.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.sidebarLeftHeight = value;
            this.setContentMinHeight();
        })));
        this.subscriptions.push(this.layoutStore.layout.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.layout = value;
            this.setContentMinHeight();
        })));
        this.subscriptions.push(this.layoutStore.windowInnerHeight.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.windowInnerHeight = value;
            this.setContentMinHeight();
        })));
        this.heightStyle = this.windowInnerHeight;
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions = removeSubscriptions(this.subscriptions);
    }
    /**
     * [scrollHeight description]
     * \@method scrollHeight
     * @return {?} [description]
     */
    get scrollHeight() {
        return this.contentInnerElement.nativeElement.scrollHeight;
    }
    /**
     * [getTitle description]
     * \@method getTitle
     * @private
     * @param {?} title [description]
     * @return {?} [description]
     */
    getTitle(title) {
        return title ? `${title} - ${this.titleTag}` : this.titleTag;
    }
    /**
     * [setMinHeight description]
     * \@method setMinHeight
     * @private
     * @return {?}
     */
    setContentMinHeight() {
        if (this.navigationEnd) {
            /** @type {?} */
            let heightStyle;
            /** @type {?} */
            const headerFooterOffsetHeight = this.headerService.offsetHeight + this.footerService.offsetHeight;
            if (this.layout === 'fixed') {
                heightStyle = this.windowInnerHeight - this.footerService.offsetHeight;
            }
            else {
                /** @type {?} */
                const sidebarRight = this.sidebarRightService.scrollHeight ?
                    this.sidebarRightService.scrollHeight - this.headerService.offsetHeight : 0;
                heightStyle = Math.max(this.windowInnerHeight - headerFooterOffsetHeight, this.sidebarLeftHeight - this.headerService.offsetHeight, sidebarRight);
            }
            if (heightStyle && heightStyle !== this.heightStyle) {
                if (this.scrollHeight > heightStyle) {
                    heightStyle = null;
                }
                this.heightStyle = heightStyle;
                this.changeDetectorRef.detectChanges();
            }
        }
    }
}
ContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-content',
                template: "<div class=\"content-wrapper\" [style.min-height.px]=\"heightStyle\">\n  <div #contentInnerElement class=\"content-inner\">\n    <ng-content select=\"[mk-layout-content-before-header]\"></ng-content>\n    <section *ngIf=\"header || description\" class=\"content-header\">\n      <h1>\n        {{header}}\n        <small *ngIf=\"description\">{{description}}</small>\n      </h1>\n      <mk-breadcrumbs></mk-breadcrumbs>\n    </section>\n    <ng-content select=\"[mk-layout-content-after-header]\"></ng-content>\n    <section class=\"content\">\n      <ng-content></ng-content>\n    </section>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}.content-wrapper{position:relative}"]
            }] }
];
/** @nocollapse */
ContentComponent.ctorParameters = () => [
    { type: LayoutStore },
    { type: RoutingService },
    { type: Title },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: SidebarRightService },
    { type: HeaderService },
    { type: FooterService },
    { type: Router }
];
ContentComponent.propDecorators = {
    contentInnerElement: [{ type: ViewChild, args: ['contentInnerElement',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentModule {
}
ContentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule, BreadcrumbsModule],
                exports: [ContentComponent],
                declarations: [ContentComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Footer Left
 */
class FooterLeftComponent {
}
FooterLeftComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-footer-left',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
            }] }
];
FooterLeftComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }]
};
/**
 * Footer Right
 */
class FooterRightComponent {
}
FooterRightComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-footer-right',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
            }] }
];
FooterRightComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }]
};
class FooterComponent {
    /**
     * @param {?} elementRef
     * @param {?} footerService
     */
    constructor(elementRef, footerService) {
        this.elementRef = elementRef;
        this.footerService = footerService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.footerService.elementRef = this.elementRef;
    }
}
FooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-footer',
                template: "<footer class=\"main-footer\">\n  <div class=\"pull-right hidden-xs\">\n    <ng-template [ngTemplateOutlet]=\"footerRightComponent?.templateRef\"></ng-template>\n  </div>\n  <ng-template [ngTemplateOutlet]=\"footerLeftComponent?.templateRef\"></ng-template>\n</footer>\n",
                styles: [":host{display:block}"]
            }] }
];
/** @nocollapse */
FooterComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: FooterService }
];
FooterComponent.propDecorators = {
    footerLeftComponent: [{ type: ContentChild, args: [FooterLeftComponent,] }],
    footerRightComponent: [{ type: ContentChild, args: [FooterRightComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FooterModule {
}
FooterModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [FooterComponent, FooterLeftComponent, FooterRightComponent],
                declarations: [FooterComponent, FooterLeftComponent, FooterRightComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Header Logo
 */
class HeaderLogoComponent {
}
HeaderLogoComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-header-logo',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
            }] }
];
HeaderLogoComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }]
};
/**
 * Header Logo Mini
 */
class HeaderLogoMiniComponent {
}
HeaderLogoMiniComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-header-logo-mini',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
            }] }
];
HeaderLogoMiniComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }]
};
/**
 * Header
 */
class HeaderComponent {
    /**
     * \@method constructor
     * @param {?} layoutStore [description]
     * @param {?} ngZone      [description]
     * @param {?} renderer2   [description]
     * @param {?} elementRef   [description]
     * @param {?} headerService   [description]
     */
    constructor(layoutStore, ngZone, renderer2, elementRef, headerService) {
        this.layoutStore = layoutStore;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.elementRef = elementRef;
        this.headerService = headerService;
        this.listeners = [];
        this.subscriptions = [];
        this.isSidebarLeftToggle = true;
        this.isSidebarRightToggle = true;
        this.logoLink = '/';
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        this.headerService.elementRef = this.headerElement;
        if (this.sidebarLeftToggleElement) {
            this.subscriptions.push(this.layoutStore.isSidebarLeftCollapsed.subscribe((/**
             * @param {?} value
             * @return {?}
             */
            (value) => {
                this.isSidebarLeftCollapsed = value;
            })));
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this.listeners.push(this.renderer2.listen(this.sidebarLeftToggleElement.nativeElement, 'click', (/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    event.preventDefault();
                    this.layoutStore.sidebarLeftCollapsed(!this.isSidebarLeftCollapsed);
                })));
            }));
        }
        if (this.sidebarRightToggleElement) {
            this.subscriptions.push(this.layoutStore.isSidebarRightCollapsed.subscribe((/**
             * @param {?} value
             * @return {?}
             */
            (value) => {
                this.isSidebarRightCollapsed = value;
            })));
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this.listeners.push(this.renderer2.listen(this.sidebarRightToggleElement.nativeElement, 'click', (/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    event.preventDefault();
                    this.layoutStore.sidebarRightCollapsed(!this.isSidebarRightCollapsed);
                })));
            }));
        }
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        this.listeners = removeListeners(this.listeners);
        this.subscriptions = removeSubscriptions(this.subscriptions);
    }
}
HeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-header',
                template: "<header #headerElement class=\"main-header\">\n  <a [routerLink]=\"logoLink\" class=\"logo\">\n    <span class=\"logo-mini\"><ng-template [ngTemplateOutlet]=\"headerLogoMiniComponent?.templateRef\"></ng-template></span>\n    <span class=\"logo-lg\"><ng-template [ngTemplateOutlet]=\"headerLogoComponent?.templateRef\"></ng-template></span>\n  </a>\n  <nav class=\"navbar navbar-static-top\">\n    <a *ngIf=\"isSidebarLeftToggle\" #sidebarLeftToggleElement href=\"#\" class=\"sidebar-toggle\">\n      <span class=\"sr-only\">Toggle navigation</span>\n      <span class=\"icon-bar\"></span>\n      <span class=\"icon-bar\"></span>\n      <span class=\"icon-bar\"></span>\n    </a>\n    <div *ngIf=\"isSidebarRightToggle\" class=\"sidebar-right-toggle\">\n      <a #sidebarRightToggleElement href=\"#\"><i class=\"fa fa-gears\"></i></a>\n    </div>\n    <ng-content></ng-content>\n  </nav>\n</header>\n",
                styles: [":host{display:block}.sidebar-right-toggle{float:right}.sidebar-right-toggle a{padding:15px;display:block;line-height:20px;cursor:pointer}"]
            }] }
];
/** @nocollapse */
HeaderComponent.ctorParameters = () => [
    { type: LayoutStore },
    { type: NgZone },
    { type: Renderer2 },
    { type: ElementRef },
    { type: HeaderService }
];
HeaderComponent.propDecorators = {
    isSidebarLeftToggle: [{ type: Input }],
    isSidebarRightToggle: [{ type: Input }],
    logoLink: [{ type: Input }],
    headerLogoComponent: [{ type: ContentChild, args: [HeaderLogoComponent,] }],
    headerLogoMiniComponent: [{ type: ContentChild, args: [HeaderLogoMiniComponent,] }],
    headerElement: [{ type: ViewChild, args: ['headerElement',] }],
    sidebarLeftToggleElement: [{ type: ViewChild, args: ['sidebarLeftToggleElement',] }],
    sidebarRightToggleElement: [{ type: ViewChild, args: ['sidebarRightToggleElement',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HeaderModule {
}
HeaderModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule],
                exports: [HeaderComponent, HeaderLogoComponent, HeaderLogoMiniComponent],
                declarations: [HeaderComponent, HeaderLogoComponent, HeaderLogoMiniComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class CollapseAnimationDirective {
    /**
     * \@method constructor
     * @param {?} elementRef [description]
     * @param {?} ngZone     [description]
     * @param {?} renderer2  [description]
     */
    constructor(elementRef, ngZone, renderer2) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.firstStart = true;
        this.collapseAnimationDuration = 350;
        this.startEventEmitter = new EventEmitter();
        this.doneEventEmitter = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set _isCollapsed(value) {
        this.lastIsCollapsed = this.isCollapsed;
        this.isCollapsed = value;
        if (!this.firstStart) {
            this.emit('start');
            if (value) {
                this.collapse();
            }
            else if (value === false) {
                this.unCollapse();
            }
        }
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        if (this.collapseAnimationDuration && this.collapseAnimationDuration !== 350) {
            this.renderer2.setStyle(this.elementRef.nativeElement, 'transition-duration', `${this.collapseAnimationDuration}ms`);
        }
        if (this.collapseAnimationTiming) {
            this.renderer2.setStyle(this.elementRef.nativeElement, 'transition-timing-function', this.collapseAnimationTiming);
        }
    }
    /**
     * \@method ngAfterContentInit
     * @return {?}
     */
    ngAfterContentInit() {
        this.emit('start');
        if (this.isCollapsed) {
            this.renderer2.setStyle(this.elementRef.nativeElement, 'display', 'none');
            this.renderer2.addClass(this.elementRef.nativeElement, 'collapsing');
        }
        this.emit('done');
        this.firstStart = false;
        this.subscriptions();
    }
    /**
     * [ngOnDestroy description]
     * \@method ngOnDestroy
     * @return {?} [description]
     */
    ngOnDestroy() {
        if (this.listener) {
            this.listener();
        }
    }
    /**
     * [subscriptions description]
     * \@method subscriptions
     * @private
     * @return {?}
     */
    subscriptions() {
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.listener = this.renderer2.listen(this.elementRef.nativeElement, 'transitionend', (/**
             * @return {?}
             */
            () => {
                if (!this.isCollapsed) {
                    this.renderer2.removeClass(this.elementRef.nativeElement, 'un-collapse');
                    this.renderer2.removeClass(this.elementRef.nativeElement, 'collapsing');
                }
                else {
                    this.renderer2.setStyle(this.elementRef.nativeElement, 'display', 'none');
                }
                requestAnimationFrame((/**
                 * @return {?}
                 */
                () => {
                    this.renderer2.removeStyle(this.elementRef.nativeElement, 'height');
                    this.emit('done');
                    this.transitioning = false;
                }));
            }));
        }));
    }
    /**
     * [unCollapse description]
     * \@method unCollapse
     * @private
     * @return {?}
     */
    unCollapse() {
        this.transitioning = true;
        this.renderer2.addClass(this.elementRef.nativeElement, 'un-collapse');
        this.renderer2.removeStyle(this.elementRef.nativeElement, 'display');
        this.renderer2.setStyle(this.elementRef.nativeElement, 'height', `${this.elementRef.nativeElement.scrollHeight}px`);
    }
    /**
     * [collapse description]
     * \@method collapse
     * @private
     * @return {?}
     */
    collapse() {
        requestAnimationFrame((/**
         * @return {?}
         */
        () => {
            if (!this.transitioning) {
                this.renderer2.setStyle(this.elementRef.nativeElement, 'height', `${this.elementRef.nativeElement.offsetHeight}px`);
                this.renderer2.addClass(this.elementRef.nativeElement, 'collapsing');
            }
            this.transitioning = true;
            requestAnimationFrame((/**
             * @return {?}
             */
            () => {
                this.renderer2.setStyle(this.elementRef.nativeElement, 'height', `0px`);
            }));
        }));
    }
    /**
     * @private
     * @param {?} phaseName
     * @return {?}
     */
    emit(phaseName) {
        /** @type {?} */
        const event = {
            element: this.elementRef.nativeElement,
            fromState: this.lastIsCollapsed === undefined ? 'void' : this.lastIsCollapsed ? '1' : '0',
            phaseName: phaseName,
            toState: this.isCollapsed === undefined ? 'void' : this.isCollapsed ? '1' : '0',
            totalTime: this.collapseAnimationDuration,
            triggerName: 'mkCollapseAnimation'
        };
        if (phaseName === 'done') {
            this.doneEventEmitter.emit(event);
        }
        else if (phaseName === 'start') {
            this.startEventEmitter.emit(event);
        }
    }
}
CollapseAnimationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mkCollapseAnimation]'
            },] }
];
/** @nocollapse */
CollapseAnimationDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 }
];
CollapseAnimationDirective.propDecorators = {
    collapseAnimationDuration: [{ type: Input }],
    collapseAnimationTiming: [{ type: Input }],
    _isCollapsed: [{ type: Input, args: ['mkCollapseAnimation',] }],
    startEventEmitter: [{ type: Output, args: ['mkCollapseAnimation.start',] }],
    doneEventEmitter: [{ type: Output, args: ['mkCollapseAnimation.done',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AnimationsModule {
}
AnimationsModule.decorators = [
    { type: NgModule, args: [{
                exports: [CollapseAnimationDirective],
                declarations: [CollapseAnimationDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class SidebarLeftToggleDirective {
    /**
     * \@method constructor
     * @param {?} elementRef [description]
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
SidebarLeftToggleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mkMenuToggle]'
            },] }
];
/** @nocollapse */
SidebarLeftToggleDirective.ctorParameters = () => [
    { type: ElementRef }
];
SidebarLeftToggleDirective.propDecorators = {
    item: [{ type: Input, args: ['mkMenuToggle',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WrapperService {
}
WrapperService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SidebarLeftComponent {
    /**
     * \@method constructor
     * @param {?} changeDetectorRef  [description]
     * @param {?} layoutStore        [description]
     * @param {?} ngZone             [description]
     * @param {?} renderer2          [description]
     * @param {?} router             [description]
     * @param {?} routingService     [description]
     * @param {?} wrapperService     [description]
     * @param {?} headerService      [description]
     */
    constructor(changeDetectorRef, layoutStore, ngZone, renderer2, router, routingService, wrapperService, headerService) {
        this.changeDetectorRef = changeDetectorRef;
        this.layoutStore = layoutStore;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.router = router;
        this.routingService = routingService;
        this.wrapperService = wrapperService;
        this.headerService = headerService;
        this.collapsedItems = [];
        this.activatedItems = [];
        this.toggleListeners = [];
        this.listeners = [];
        this.itemsByIds = {};
        this.runningAnimations = 0;
        this.subscriptions = [];
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        this.subscriptions.push(this.layoutStore.sidebarLeftMenu.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        value => {
            this.menu = value;
            this.monkeyPatchMenu(this.menu);
            if (this.initialized) {
                this.setMenuListeners(this.activeUrl);
                this.setSidebarListeners();
                this.setMenuTogglesListeners();
            }
            this.initialized = true;
        })));
        this.subscriptions.push(this.layoutStore.sidebarLeftMenuActiveUrl.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        value => {
            this.activeUrl = value;
            this.setMenuListeners(value);
        })));
        this.subscriptions.push(this.routingService.events.subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            if (event instanceof NavigationEnd) {
                this.activeUrl = event.url;
                this.setMenuListeners(event.url);
            }
        })));
        this.setSidebarListeners();
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        this.setMenuTogglesListeners();
        this.checkMenuWithoutChildren();
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions = removeSubscriptions(this.subscriptions);
        this.listeners = removeListeners(this.listeners);
        this.toggleListeners = removeListeners(this.toggleListeners);
    }
    /**
     * [setSidebarListeners description]
     * \@method setSidebarListeners
     * @return {?}
     */
    setSidebarListeners() {
        this.subscriptions.push(this.layoutStore.layout.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.layout = value;
            this.setSidebarHeight();
        })));
        this.subscriptions.push(this.layoutStore.windowInnerHeight.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.windowInnerHeight = value;
            this.setSidebarHeight();
        })));
        this.subscriptions.push(this.layoutStore.sidebarLeftMenu.subscribe((/**
         * @return {?}
         */
        () => {
            this.changeDetectorRef.detectChanges();
        })));
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.listeners.push(this.renderer2.listen(this.sidebarElement.nativeElement, 'mouseenter', (/**
             * @return {?}
             */
            () => {
                this.layoutStore.sidebarLeftMouseOver(true);
            })));
            this.listeners.push(this.renderer2.listen(this.sidebarElement.nativeElement, 'mouseleave', (/**
             * @return {?}
             */
            () => {
                this.layoutStore.sidebarLeftMouseOver(false);
            })));
        }));
        this.subscriptions.push(this.layoutStore.windowInnerWidth.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.windowInnerWidth = value;
            if (!this.isSidebarLeftCollapsed && this.windowInnerWidth <= 767) {
                this.layoutStore.sidebarLeftCollapsed(true);
            }
            else if (this.windowInnerWidth > 767 && this.isSidebarLeftCollapsed && !this.isSidebarLeftExpandOnOver) {
                this.layoutStore.sidebarLeftCollapsed(false);
            }
        })));
        this.subscriptions.push(this.layoutStore.isSidebarLeftMouseOver.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.isSidebarLeftMouseOver = value;
            if (this.isSidebarLeftExpandOnOver) {
                this.layoutStore.sidebarLeftCollapsed(!value);
            }
        })));
        this.subscriptions.push(this.layoutStore.isSidebarLeftExpandOnOver.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.isSidebarLeftExpandOnOver = value;
            if (this.windowInnerWidth > 767 && this.isSidebarLeftCollapsed !== undefined) {
                this.layoutStore.sidebarLeftCollapsed(value);
            }
        })));
        this.subscriptions.push(this.layoutStore.isSidebarLeftCollapsed.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.isSidebarLeftCollapsed = value;
            if (this.windowInnerWidth <= 767) {
                if (value) {
                    this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-open');
                }
                else {
                    this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-open');
                }
            }
            else {
                if (this.isSidebarLeftExpandOnOver && !this.isSidebarLeftMouseOver && !value) {
                    this.layoutStore.sidebarLeftExpandOnOver(false);
                }
                if (value) {
                    this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-collapse');
                    if (this.isSidebarLeftExpandOnOver) {
                        this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-expanded-on-hover');
                    }
                }
                else {
                    this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-collapse');
                    if (this.isSidebarLeftExpandOnOver) {
                        this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-expanded-on-hover');
                    }
                }
            }
        })));
        this.subscriptions.push(this.layoutStore.isSidebarLeftMini.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            if (value) {
                this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-mini');
            }
            else {
                this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-mini');
            }
        })));
    }
    /**
     * [setMenuListeners description]
     * \@method setMenuListeners
     * @param {?} url
     * @return {?}
     */
    setMenuListeners(url) {
        if (url === '/') {
            this.activeItems(url);
            this.changeDetectorRef.detectChanges();
        }
        else {
            /** @type {?} */
            const primaryOutlet = this.router.parseUrl(url).root.children[PRIMARY_OUTLET];
            if (primaryOutlet) {
                this.activeItems(primaryOutlet.toString());
                this.changeDetectorRef.detectChanges();
            }
        }
        if (this.windowInnerWidth <= 767 || this.isSidebarLeftExpandOnOver) {
            this.layoutStore.sidebarLeftCollapsed(true);
        }
    }
    /**
     * [getIconClasses description]
     * \@method getIconClasses
     * @param {?} item [description]
     * @return {?} [description]
     */
    getIconClasses(item) {
        if (item.iconClasses || item.iconClasses === '') {
            return item.iconClasses;
        }
        else {
            return 'fa fa-circle-o';
        }
    }
    /**
     * [visibilityStateStart description]
     * \@method visibilityStateStart
     * @param {?} event [description]
     * @return {?}
     */
    visibilityStateStart(event) {
        this.runningAnimations++;
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.runningAnimations--;
                if (!this.runningAnimations) {
                    this.layoutStore.setSidebarLeftElementHeight(this.sidebarElement.nativeElement.offsetHeight);
                }
            }), event.totalTime);
        }));
    }
    /**
     * [uncollapseItemParents description]
     * \@method uncollapseItemParents
     * @private
     * @param {?} item           [description]
     * @param {?=} isActive       [description]
     * @return {?}
     */
    uncollapseItemParents(item, isActive = false) {
        if (isActive) {
            item.isActive = true;
            this.activatedItems.push(item);
        }
        item.isCollapsed = false;
        this.collapsedItems.push(item);
        if (item.parentId) {
            this.uncollapseItemParents(this.itemsByIds[item.parentId], isActive);
        }
    }
    /**
     * [findItemsByUrl description]
     * \@method findItemsByUrl
     * @private
     * @param {?} url   [description]
     * @param {?} items [description]
     * @param {?=} returnItems [description]
     * @return {?} [description]
     */
    findItemsByUrl(url, items, returnItems = []) {
        items.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            if (item.route === url) {
                returnItems.push(item);
            }
            else if (item.children) {
                this.findItemsByUrl(url, item.children, returnItems);
            }
        }));
        return returnItems;
    }
    /**
     * [activeItems description]
     * \@method activeItems
     * @private
     * @param {?} url [description]
     * @return {?}
     */
    activeItems(url) {
        this.activatedItems.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            item.isActive = false;
        }));
        this.activatedItems = [];
        this.collapsedItems.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            item.isActive = false;
            item.isCollapsed = true;
        }));
        this.collapsedItems = [];
        /** @type {?} */
        const items = this.findItemsByUrl(url, this.menu);
        items.forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            item.isActive = true;
            this.uncollapseItemParents(item, true);
            this.activatedItems.push(item);
        }));
    }
    /**
     * [monkeyPatchMenu description]
     * \@method monkeyPatchMenu
     * @private
     * @param {?} items    [description]
     * @param {?=} parentId [description]
     * @return {?}
     */
    monkeyPatchMenu(items, parentId) {
        items.forEach((/**
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
        (item, index) => {
            item.id = parentId ? Number(parentId + '' + (index + 1)) : index + 1;
            if (parentId) {
                item.parentId = parentId;
            }
            if (!item.disableCollapse) {
                item.isCollapsed = true;
            }
            item.isActive = false;
            if (parentId || item.children) {
                this.itemsByIds[item.id] = item;
            }
            if (item.children) {
                this.monkeyPatchMenu(item.children, item.id);
            }
        }));
    }
    /**
     * [setMenuTogglesListeners description]
     * \@method setMenuTogglesListeners
     * @private
     * @return {?}
     */
    setMenuTogglesListeners() {
        this.toggleListeners = removeListeners(this.toggleListeners);
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.sidebarLeftToggleDirectives.forEach((/**
             * @param {?} menuToggle
             * @return {?}
             */
            (menuToggle) => {
                this.toggleListeners.push(this.renderer2.listen(menuToggle.elementRef.nativeElement, 'click', (/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    event.preventDefault();
                    if (menuToggle.item.isCollapsed) {
                        this.collapsedItems.forEach((/**
                         * @param {?} item
                         * @return {?}
                         */
                        (item) => {
                            if (!item.disableCollapse) {
                                item.isCollapsed = true;
                            }
                        }));
                        this.collapsedItems = [];
                        this.uncollapseItemParents(menuToggle.item);
                    }
                    else {
                        menuToggle.item.isCollapsed = !menuToggle.item.isCollapsed;
                    }
                    this.changeDetectorRef.detectChanges();
                })));
            }));
        }));
    }
    /**
     * [checkMenuWithoutChildren description]
     * \@method checkMenuWithoutChildren
     * @private
     * @return {?}
     */
    checkMenuWithoutChildren() {
        /** @type {?} */
        let menuHaveChildren;
        this.menu.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            if (item.children) {
                return menuHaveChildren = true;
            }
        }));
        if (!menuHaveChildren) {
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.layoutStore.setSidebarLeftElementHeight(this.sidebarElement.nativeElement.offsetHeight);
                }));
            }));
        }
    }
    /**
     * [setSidebarHeight description]
     * \@method setSidebarHeight
     * @private
     * @return {?}
     */
    setSidebarHeight() {
        if (this.layout === 'fixed') {
            /** @type {?} */
            const height = this.windowInnerHeight - this.headerService.offsetHeight;
            if (height && height !== this.sidebarHeight) {
                this.sidebarHeight = height;
                this.sidebarOverflow = 'auto';
                this.changeDetectorRef.detectChanges();
            }
        }
        else if (this.sidebarHeight) {
            this.sidebarOverflow = this.sidebarHeight = null;
            this.changeDetectorRef.detectChanges();
        }
    }
}
SidebarLeftComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-sidebar-left',
                template: "<aside class=\"main-sidebar\">\n  <section class=\"sidebar\" #sidebarElement [style.height.px]=\"sidebarHeight\" [style.overflow]=\"sidebarOverflow\">\n    <ng-content></ng-content>\n  \t<ul class=\"sidebar-menu\">\n      <ng-container *ngFor=\"let item of menu\">\n        <ng-container *ngTemplateOutlet=\"sidebarInner; context: {item: item}\"></ng-container>\n      </ng-container>\n  \t</ul>\n  </section>\n</aside>\n\n<ng-template #sidebarInner let-item=\"item\">\n  <li [class.active]=\"item.isActive\" [class.header]=\"item.separator\" [class.menu-open]=\"!item.isCollapsed\">\n    <span *ngIf=\"item.separator\">{{item.label}}</span>\n    <a *ngIf=\"!item.separator && item.route\" [routerLink]=\"item.route\">\n    \t<i [class]=\"getIconClasses(item)\"></i><span>{{item.label}}</span>\n    \t<span *ngIf=\"item.children || item.pullRights\" class=\"pull-right-container\">\n    \t\t<span *ngFor=\"let rightItem of item.pullRights\" class=\"pull-right {{rightItem.classes}}\">{{rightItem.text}}</span>\n    \t  <i *ngIf=\"!item.pullRights\" class=\"fa fa-angle-left pull-right\"></i>\n    \t</span>\n    </a>\n    <a *ngIf=\"!item.separator && !item.route\" href=\"#\" [mkMenuToggle]=\"item\">\n    \t<i [class]=\"getIconClasses(item)\"></i><span>{{item.label}}</span>\n    \t<span *ngIf=\"item.children || item.pullRights\" class=\"pull-right-container\">\n    \t\t<span *ngFor=\"let rightItem of item.pullRights\" class=\"pull-right {{rightItem.classes}}\">{{rightItem.text}}</span>\n    \t  <i *ngIf=\"!item.pullRights\" class=\"fa fa-angle-left pull-right\"></i>\n    \t</span>\n    </a>\n    <ul *ngIf=\"item.children\" [mkCollapseAnimation]=\"item.isCollapsed\" (mkCollapseAnimation.start)=\"visibilityStateStart($event)\" class=\"treeview-menu\">\n      <ng-container *ngFor=\"let item of item.children\">\n        <ng-container *ngTemplateOutlet=\"sidebarInner; context: {item: item}\"></ng-container>\n      </ng-container>\n    </ul>\n  </li>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".treeview-menu.collapse{display:none}.treeview-menu,.treeview-menu.collapse.in{display:block}"]
            }] }
];
/** @nocollapse */
SidebarLeftComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: LayoutStore },
    { type: NgZone },
    { type: Renderer2 },
    { type: Router },
    { type: RoutingService },
    { type: WrapperService },
    { type: HeaderService }
];
SidebarLeftComponent.propDecorators = {
    sidebarElement: [{ type: ViewChild, args: ['sidebarElement',] }],
    sidebarLeftToggleDirectives: [{ type: ViewChildren, args: [SidebarLeftToggleDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SidebarLeftModule {
}
SidebarLeftModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule, AnimationsModule],
                exports: [SidebarLeftComponent],
                declarations: [SidebarLeftToggleDirective, SidebarLeftComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SidebarRightComponent {
    /**
     * @param {?} elementRef
     * @param {?} renderer2
     * @param {?} layoutStore
     * @param {?} sidebarRightService
     * @param {?} wrapperService
     */
    constructor(elementRef, renderer2, layoutStore, sidebarRightService, wrapperService) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.layoutStore = layoutStore;
        this.sidebarRightService = sidebarRightService;
        this.wrapperService = wrapperService;
        this.listeners = [];
        this.subscriptions = [];
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        this.renderer2.addClass(this.elementRef.nativeElement, 'control-sidebar');
        this.subscriptions.push(this.layoutStore.isSidebarRightCollapsed.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        value => {
            this.isSidebarRightCollapsed = value;
            if (!value) {
                this.renderer2.addClass(this.elementRef.nativeElement, 'control-sidebar-open');
                if (!this.isSidebarRightOverContent) {
                    this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'control-sidebar-open');
                }
            }
            else {
                this.renderer2.removeClass(this.elementRef.nativeElement, 'control-sidebar-open');
                if (!this.isSidebarRightOverContent) {
                    this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'control-sidebar-open');
                }
            }
        })));
        this.subscriptions.push(this.layoutStore.isSidebarRightOverContent.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.isSidebarRightOverContent = value;
            if (!this.isSidebarRightCollapsed) {
                if (value) {
                    this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'control-sidebar-open');
                }
                else {
                    this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'control-sidebar-open');
                }
            }
        })));
        this.subscriptions.push(this.layoutStore.sidebarRightSkin.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            if (this.skin !== value) {
                this.renderer2.removeClass(this.elementRef.nativeElement, `control-sidebar-${this.skin}`);
            }
            this.skin = value;
            this.renderer2.addClass(this.elementRef.nativeElement, `control-sidebar-${value}`);
        })));
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        this.sidebarRightService.elementRef = this.sidebarContentElement;
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        this.listeners = removeListeners(this.listeners);
        this.subscriptions = removeSubscriptions(this.subscriptions);
    }
}
SidebarRightComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-sidebar-right',
                template: "<div #sidebarContentElement class=\"control-sidebar-content\">\n  <ng-content></ng-content>\n</div>\n<div class=\"control-sidebar-bg\"></div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block;height:100%}.control-sidebar-bg{z-index:-1}/deep/ .tab-content{padding:10px 15px}"]
            }] }
];
/** @nocollapse */
SidebarRightComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: LayoutStore },
    { type: SidebarRightService },
    { type: WrapperService }
];
SidebarRightComponent.propDecorators = {
    sidebarContentElement: [{ type: ViewChild, args: ['sidebarContentElement',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SidebarRightModule {
}
SidebarRightModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [SidebarRightComponent],
                declarations: [SidebarRightComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WrapperComponent {
    /**
     * @param {?} elementRef
     * @param {?} renderer2
     * @param {?} layoutStore
     * @param {?} wrapperService
     * @param {?} ngZone
     */
    constructor(elementRef, renderer2, layoutStore, wrapperService, ngZone) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.layoutStore = layoutStore;
        this.wrapperService = wrapperService;
        this.ngZone = ngZone;
        this.listeners = [];
        this.subscriptions = [];
    }
    /**
     * [ngOnInit description]
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        this.layoutStore.setWindowInnerHeight(window.innerHeight);
        this.layoutStore.setWindowInnerWidth(window.innerWidth);
        this.wrapperService.wrapperElementRef = this.elementRef;
        this.subscriptions.push(this.layoutStore.wrapperClasses.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.classes = value ? value : null;
        })));
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.listeners.push(this.renderer2.listen('window', 'resize', throttle((/**
             * @return {?}
             */
            () => {
                this.layoutStore.setWindowInnerHeight(window.innerHeight);
                this.layoutStore.setWindowInnerWidth(window.innerWidth);
            }), 250)));
        }));
        this.subscriptions.push(this.layoutStore.layout.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            value === 'fixed' ? this.renderer2.addClass(this.elementRef.nativeElement, 'fixed') :
                this.renderer2.removeClass(this.elementRef.nativeElement, 'fixed');
            value === 'boxed' ? this.renderer2.addClass(this.elementRef.nativeElement, 'layout-boxed') :
                this.renderer2.removeClass(this.elementRef.nativeElement, 'layout-boxed');
        })));
        this.subscriptions.push(this.layoutStore.skin.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            if (value) {
                if (this.skin && this.skin !== value) {
                    this.renderer2.removeClass(this.elementRef.nativeElement, `skin-${this.skin}`);
                }
                this.skin = value;
                this.renderer2.addClass(this.elementRef.nativeElement, `skin-${this.skin}`);
            }
        })));
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions = removeSubscriptions(this.subscriptions);
        this.listeners = removeListeners(this.listeners);
    }
}
WrapperComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-layout-wrapper',
                template: "<div class=\"wrapper overflow\" [ngClass]=\"classes\">\n  <ng-content></ng-content>\n</div>\n",
                styles: [".wrapper.overflow{overflow:hidden}:host{display:block}:host /deep/ .sidebar-right-toggle>a{color:#fff}:host.sidebar-mini.sidebar-collapse /deep/ .treeview-menu.collapsing{height:auto!important}:host /deep/ .sidebar-right-toggle>a:hover{background:rgba(0,0,0,.1)}:host.skin-black /deep/ .sidebar-right-toggle>a,:host.skin-black-light /deep/ .sidebar-right-toggle>a{color:#333;border-right-width:0}:host.skin-black /deep/ .sidebar-right-toggle>a:hover,:host.skin-black-light /deep/ .sidebar-right-toggle>a:hover{background-color:#fff;color:#999}:host.skin-black /deep/ .sidebar-right-toggle>a{border-left:1px solid #eee}:host.skin-black-light /deep/ .sidebar-right-toggle>a{border-left:1px solid #d2d6de}"]
            }] }
];
/** @nocollapse */
WrapperComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: LayoutStore },
    { type: WrapperService },
    { type: NgZone }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WrapperModule {
}
WrapperModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [WrapperComponent],
                declarations: [WrapperComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LayoutService {
    /**
     * \@method constructor
     * @param {?} routingService [description]
     */
    constructor(routingService) {
        this.routingService = routingService;
        this.isCustomLayout = new BehaviorSubject(true);
        this.init();
    }
    /**
     * [init description]
     * \@method init
     * @private
     * @return {?} [description]
     */
    init() {
        this.routingService.onChange.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            if (value && value[value.length - 1]) {
                if (this.customLayout === undefined || this.customLayout !== value[value.length - 1].data['disableLayout']) {
                    this.isCustomLayout.next(!!value[value.length - 1].data['customLayout']);
                }
                this.customLayout = value[value.length - 1].data['customLayout'];
            }
        }));
    }
}
LayoutService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
LayoutService.ctorParameters = () => [
    { type: RoutingService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * [InjectionToken description]
 * @type {?}
 */
const LayoutConfigToken = new InjectionToken('layoutConfig');
/**
 * [layoutStoreFactory description]
 * @param {?} layoutConfig
 * @return {?}
 */
function layoutStoreFactory(layoutConfig) {
    return new LayoutStore(layoutConfig);
}
/**
 * [layoutProviders description]
 * @param {?} layoutConfig
 * @return {?}
 */
function layoutProvider(layoutConfig) {
    return [{
            provide: LayoutStore,
            useFactory: layoutStoreFactory,
            deps: [LayoutConfigToken]
        }, {
            provide: LayoutConfigToken,
            useValue: layoutConfig
        }
    ];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LayoutModule {
    /**
     * \@method constructor
     * @param {?} parentModule [description]
     */
    constructor(parentModule) {
        if (parentModule) {
            throw new Error('LayoutModule is already loaded. Import it in the AppModule only!');
        }
    }
    /**
     * [forRoot description]
     * \@method forRoot
     * @param {?} layoutConfig [description]
     * @return {?} [description]
     */
    static forRoot(layoutConfig) {
        return {
            ngModule: LayoutModule,
            providers: [...layoutProvider(layoutConfig), LayoutService]
        };
    }
}
LayoutModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule],
                exports: [ContentModule, FooterModule, HeaderModule, SidebarLeftModule, SidebarRightModule, WrapperModule],
                providers: [RoutingService, WrapperService, SidebarRightService, HeaderService, FooterService]
            },] }
];
/** @nocollapse */
LayoutModule.ctorParameters = () => [
    { type: LayoutModule, decorators: [{ type: Optional }, { type: SkipSelf }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const colorsAliases = [
    'default',
    'primary',
    'danger',
    'warning',
    'info',
    'success'
];
/** @type {?} */
const colors = {
    'aqua': '#00c0ef',
    'aqua-active': '#00a7d0',
    'black': '#111111',
    'black-active': '#000000',
    'blue': '#0073b7',
    'blue-active': '#005384',
    'fuchsia': '#f012be',
    'fuchsia-active': '#db0ead',
    'green': '#00a65a',
    'green-active': '#008d4c',
    'gray': '#d2d6de',
    'gray-active': '#b5bbc8',
    'gray-light': '#f7f7f7',
    'light-blue': '#3c8dbc',
    'light-blue-active': '#357ca5',
    'lime': '#01ff70',
    'lime-active': '#00e765',
    'maroon': '#d81b60',
    'maroon-active': '#ca195a',
    'navy': '#001f3f',
    'navy-active': '#001a35',
    'olive': '#3d9970',
    'olive-active': '#368763',
    'orange': '#ff851b',
    'orange-active': '#ff7701',
    'purple': '#605ca8',
    'purple-active': '#555299',
    'red': '#dd4b39',
    'red-active': '#d33724',
    'teal': '#39cccc',
    'teal-active': '#30bbbb',
    'yellow': '#f39c12',
    'yellow-active': '#db8b0b',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class ColorService {
    /**
     * \@method constructor
     * @param {?} renderer2 [description]
     * @param {?} elementRef [description]
     */
    constructor(renderer2, elementRef) {
        this.renderer2 = renderer2;
        this.elementRef = elementRef;
        // this.init();
        // console.log(this);
    }
    /**
     * [setBackgroundColor description]
     * \@method setBackgroundColor
     * @param {?} color              [description]
     * @param {?} condition          [description]
     * @param {?} property           [description]
     * @param {?} prefix             [description]
     * @return {?}
     */
    setBackgroundColor(color, condition, property, prefix) {
        if (color && condition) {
            this.resetBackgroundColor();
            if (colors[color]) {
                this.renderer2.addClass(this.elementRef.nativeElement, 'bg-color');
                this.currentBackgroundStyle = { property: property, color: colors[color] };
                this.renderer2.setStyle(this.elementRef.nativeElement, property, colors[color]);
            }
            else {
                this.renderer2.removeClass(this.elementRef.nativeElement, 'bg-color');
                if (color.indexOf('#') === 0 || color.indexOf('rgb') === 0) {
                    this.currentBackgroundStyle = { property: property, color: color };
                    this.renderer2.setStyle(this.elementRef.nativeElement, property, color);
                }
                else if (colorsAliases.indexOf(color) !== -1) {
                    this.currentBackgroundClass = prefix ? `${prefix}-${color}` : color;
                    this.renderer2.addClass(this.elementRef.nativeElement, this.currentBackgroundClass);
                }
            }
        }
    }
    /**
     * [resetBackgroundColor description]
     * \@method resetBackgroundColor
     * @return {?}
     */
    resetBackgroundColor() {
        if (this.currentBackgroundStyle) {
            this.renderer2.removeStyle(this.elementRef.nativeElement, this.currentBackgroundStyle.property, this.currentBackgroundStyle.color);
        }
        else if (this.currentBackgroundClass) {
            this.renderer2.removeClass(this.elementRef.nativeElement, this.currentBackgroundClass);
        }
    }
    /**
     * [setFontColor description]
     * \@method setFontColor
     * @param {?} color        [description]
     * @return {?}
     */
    setFontColor(color) {
        if (color) {
            this.resetFontColor();
            if (color.startsWith('#') || color.startsWith('rgb')) {
                this.currentFontStyle = color;
                this.renderer2.setStyle(this.elementRef.nativeElement, 'color', color);
            }
            else {
                this.currentFontClass = `text-${color}`;
                this.renderer2.addClass(this.elementRef.nativeElement, this.currentFontClass);
            }
        }
    }
    /**
     * [resetFontColor description]
     * \@method resetFontColor
     * @return {?} [description]
     */
    resetFontColor() {
        if (this.currentFontStyle) {
            this.renderer2.removeStyle(this.elementRef.nativeElement, 'color', this.currentFontStyle);
        }
        else if (this.currentFontClass) {
            this.renderer2.removeClass(this.elementRef.nativeElement, this.currentFontClass);
        }
    }
}
ColorService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ColorService.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BackgroundColorDirective {
    /**
     * \@method constructor
     * @param {?} elementRef   [description]
     * @param {?} renderer2    [description]
     * @param {?} colorService [description]
     */
    constructor(elementRef, renderer2, colorService) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.colorService = colorService;
        this.condition = true;
    }
    /**
     * @param {?} color
     * @return {?}
     */
    set color(color) {
        this.colorService.setBackgroundColor(color, this.condition, this.property, this.prefix);
    }
}
BackgroundColorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mkColor]',
                providers: [ColorService]
            },] }
];
/** @nocollapse */
BackgroundColorDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ColorService }
];
BackgroundColorDirective.propDecorators = {
    condition: [{ type: Input, args: ['mkColorCondition',] }],
    prefix: [{ type: Input, args: ['mkColorPrefix',] }],
    property: [{ type: Input, args: ['mkColorProperty',] }],
    color: [{ type: Input, args: ['mkColor',] }]
};
class ColorDirective {
    /**
     * \@method constructor
     * @param {?} elementRef   [description]
     * @param {?} renderer2    [description]
     * @param {?} colorService [description]
     */
    constructor(elementRef, renderer2, colorService) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.colorService = colorService;
    }
    /**
     * @param {?} color
     * @return {?}
     */
    set color(color) {
        this.colorService.setFontColor(color);
    }
}
ColorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mkFontColor]',
                providers: [ColorService]
            },] }
];
/** @nocollapse */
ColorDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ColorService }
];
ColorDirective.propDecorators = {
    color: [{ type: Input, args: ['mkFontColor',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ColorModule {
}
ColorModule.decorators = [
    { type: NgModule, args: [{
                exports: [BackgroundColorDirective, ColorDirective],
                declarations: [BackgroundColorDirective, ColorDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class AccordionToggleDirective {
    /**
     * \@method constructor
     * @param {?} elementRef [description]
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
AccordionToggleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mkAccordionToggle]'
            },] }
];
/** @nocollapse */
AccordionToggleDirective.ctorParameters = () => [
    { type: ElementRef }
];
AccordionToggleDirective.propDecorators = {
    accordionComponent: [{ type: Input, args: ['mkAccordionToggle',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class AccordionHeaderComponent {
}
AccordionHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-accordion-header',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
            }] }
];
AccordionHeaderComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }]
};
/*
 *
 */
class AccordionContentComponent {
}
AccordionContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-accordion-content',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
            }] }
];
AccordionContentComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }]
};
/*
 *
 */
class AccordionComponent {
    constructor() {
        this.contentStyleClass = 'box-body';
        this.headerStyleClass = 'box-header with-border';
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        this.headerStyleColor = this.headerColor;
        if (!this.header && !this.accordionHeaderComponent) {
            throw new Error('Attribute "header" OR Component "mk-+accordion-header" is required for component "mk-+accordion"');
        }
        if (this.accordionContentComponent) {
            this.contentTemplateRef = this.accordionContentComponent.templateRef;
        }
        else {
            this.contentTemplateRef = this.templateRef;
        }
    }
}
AccordionComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-accordion',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
            }] }
];
AccordionComponent.propDecorators = {
    borderColor: [{ type: Input }],
    contentColor: [{ type: Input }],
    contentStyleClass: [{ type: Input }],
    header: [{ type: Input }],
    headerColor: [{ type: Input }],
    headerColorHover: [{ type: Input }],
    headerStyleClass: [{ type: Input }],
    accordionHeaderComponent: [{ type: ContentChild, args: [AccordionHeaderComponent,] }],
    accordionContentComponent: [{ type: ContentChild, args: [AccordionContentComponent,] }],
    templateRef: [{ type: ViewChild, args: ['templateRef',] }]
};
/*
 *
 */
class AccordionGroupComponent {
    /**
     * \@method constructor
     * @param {?} changeDetectorRef [description]
     * @param {?} ngZone            [description]
     * @param {?} renderer2         [description]
     */
    constructor(changeDetectorRef, ngZone, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.activeIndex = [0];
        // @TODO change types for listeners to all files
        this.listeners = [];
        // @TODO change types for subscriptions to all files
        this.subscriptions = [];
        this.styleClass = 'box-group';
        this.onCollapseStart = new EventEmitter();
        this.onCollapseDone = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set _activeIndex(value) {
        this.activeIndex = value instanceof Array ? value : [value];
    }
    /**
     * [headerMouseLeave description]
     * \@method headerMouseLeave
     * @param {?} accordion [description]
     * @return {?}
     */
    static headerMouseLeave(accordion) {
        accordion.headerStyleColor = accordion.headerColor;
    }
    /**
     * [headerMouseEnter description]
     * \@method headerMouseEnter
     * @param {?} accordion [description]
     * @return {?}
     */
    static headerMouseEnter(accordion) {
        if (accordion.headerColorHover) {
            accordion.headerStyleColor = accordion.headerColorHover;
        }
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterContentInit() {
        this.setAccordionsIndex();
        this.updateAccordionIsCollapsed();
        this.subscriptions.push(this.accordionComponents.changes.subscribe((/**
         * @return {?}
         */
        () => {
            this.setAccordionsIndex();
        })));
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        this.setAccordionsToggle();
        this.subscriptions.push(this.accordionToggleDirectives.changes.subscribe((/**
         * @return {?}
         */
        () => {
            this.setAccordionsToggle();
        })));
    }
    /**
     * [ngOnChanges description]
     * \@method ngOnChanges
     * @param {?} changes [description]
     * @return {?} [description]
     */
    ngOnChanges(changes) {
        if (changes._activeIndex.firstChange === false) {
            this.updateAccordionIsCollapsed();
        }
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        removeListeners(this.listeners);
        removeSubscriptions(this.subscriptions);
    }
    /**
     * [toggleAccordion description]
     * \@method toggleAccordion
     * @param {?} event       [description]
     * @param {?} toggleIndex [description]
     * @return {?}
     */
    toggleAccordion(event, toggleIndex) {
        event.preventDefault();
        /** @type {?} */
        const indexOf = this.activeIndex['indexOf'](toggleIndex);
        if (indexOf === -1) {
            if (this.isMultiple) {
                this.activeIndex.push(toggleIndex);
            }
            else {
                this.activeIndex = [toggleIndex];
            }
        }
        else {
            if (this.isMultiple) {
                this.activeIndex.splice(indexOf, 1);
            }
            else {
                this.activeIndex = [];
            }
        }
        this.updateAccordionIsCollapsed();
    }
    /**
     * [collapseStart description]
     * \@method collapseStart
     * @param {?} event [description]
     * @param {?} accordion [description]
     * @return {?}
     */
    collapseStart(event, accordion) {
        accordion.isCollapsing = true;
        this.onCollapseStart.emit({ animationEvent: event, index: accordion.index });
    }
    /**
     * [collapseDone description]
     * \@method collapseDone
     * @param {?} event [description]
     * @param {?} accordion [description]
     * @return {?}
     */
    collapseDone(event, accordion) {
        accordion.isCollapsing = false;
        this.onCollapseDone.emit({ animationEvent: event, index: accordion.index });
    }
    /**
     * [setAccordionsIndex description]
     * \@method setAccordionsIndex
     * @private
     * @return {?}
     */
    setAccordionsIndex() {
        this.accordionComponents.forEach((/**
         * @param {?} accordion
         * @param {?} index
         * @return {?}
         */
        (accordion, index) => {
            accordion.index = index;
        }));
    }
    /**
     * [setAccordionsToggle description]
     * \@method setAccordionsToggle
     * @private
     * @return {?}
     */
    setAccordionsToggle() {
        this.listeners = removeListeners(this.listeners);
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.accordionToggleDirectives.forEach((/**
             * @param {?} accordionToggle
             * @return {?}
             */
            (accordionToggle) => {
                this.listeners.push(this.renderer2.listen(accordionToggle.elementRef.nativeElement, 'click', (/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    this.toggleAccordion(event, accordionToggle.accordionComponent.index);
                    this.changeDetectorRef.detectChanges();
                })));
                this.listeners.push(this.renderer2.listen(accordionToggle.elementRef.nativeElement, 'mouseenter', (/**
                 * @return {?}
                 */
                () => {
                    AccordionGroupComponent.headerMouseEnter(accordionToggle.accordionComponent);
                    this.changeDetectorRef.detectChanges();
                })));
                this.listeners.push(this.renderer2.listen(accordionToggle.elementRef.nativeElement, 'mouseleave', (/**
                 * @return {?}
                 */
                () => {
                    AccordionGroupComponent.headerMouseLeave(accordionToggle.accordionComponent);
                    this.changeDetectorRef.detectChanges();
                })));
            }));
        }));
    }
    /**
     * [updateAccordionIsCollapsed description]
     * \@method updateAccordionIsCollapsed
     * @private
     * @return {?}
     */
    updateAccordionIsCollapsed() {
        this.accordionComponents.forEach((/**
         * @param {?} accordion
         * @param {?} index
         * @return {?}
         */
        (accordion, index) => {
            accordion.isCollapsed = this.activeIndex.indexOf(index) === -1;
        }));
    }
}
AccordionGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-accordion-group',
                template: "<div [ngClass]=\"styleClass\">\n  <div *ngFor=\"let accordion of accordionComponents\" class=\"panel box\" [mkColor]=\"accordion.borderColor\" mkColorProperty=\"border-top-color\" mkColorPrefix=\"box\">\n    <div [ngClass]=\"accordion.headerStyleClass\" [class.no-border]=\"accordion.isCollapsed && !accordion.isCollapsing\">\n      <h4 class=\"box-title\">\n        <a [mkAccordionToggle]=\"accordion\" href=\"#\" [mkFontColor]=\"accordion.headerStyleColor\" [class.collapsed]=\"accordion.isCollapsed\">\n          {{accordion.header}}\n          <ng-template *ngIf=\"!accordion.header\" [ngTemplateOutlet]=\"accordion.accordionHeaderComponent?.templateRef\"></ng-template>\n        </a>\n      </h4>\n    </div>\n    <div class=\"panel-collapse\" [mkCollapseAnimation]=\"accordion.isCollapsed\" (mkCollapseAnimation.start)=\"collapseStart($event, accordion)\" (mkCollapseAnimation.done)=\"collapseDone($event, accordion)\">\n      <div [ngClass]=\"accordion.contentStyleClass\" [mkFontColor]=\"accordion.contentColor\">\n        <ng-template [ngTemplateOutlet]=\"accordion.contentTemplateRef\"></ng-template>\n      </div>\n    </div>\n  </div>\n</div>\n"
            }] }
];
/** @nocollapse */
AccordionGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 }
];
AccordionGroupComponent.propDecorators = {
    _activeIndex: [{ type: Input, args: ['activeIndex',] }],
    isMultiple: [{ type: Input }],
    styleClass: [{ type: Input }],
    onCollapseStart: [{ type: Output }],
    onCollapseDone: [{ type: Output }],
    accordionComponents: [{ type: ContentChildren, args: [AccordionComponent,] }],
    accordionToggleDirectives: [{ type: ViewChildren, args: [AccordionToggleDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AccordionModule {
}
AccordionModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, AnimationsModule, ColorModule],
                exports: [AccordionHeaderComponent, AccordionContentComponent, AccordionComponent, AccordionGroupComponent],
                declarations: [AccordionToggleDirective, AccordionHeaderComponent,
                    AccordionContentComponent, AccordionComponent, AccordionGroupComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class AlertComponent {
    /**
     * \@method constructor
     * @param {?} changeDetectorRef [description]
     * @param {?} ngZone            [description]
     * @param {?} renderer2         [description]
     * @param {?} viewContainerRef  [description]
     */
    constructor(changeDetectorRef, ngZone, renderer2, viewContainerRef) {
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.viewContainerRef = viewContainerRef;
        this.dismissibleClass = 'alert-dismissible';
        this.isDismissible = true;
        this.remove = false;
        this.type = 'alert';
        this.listeners = [];
        this.backgroundColor = 'danger';
        this.styleClass = '';
        this.onCollapseStart = new EventEmitter();
        this.onCollapseDone = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set callout(value) {
        this.type = value ? 'callout' : 'alert';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set _isDismissible(value) {
        this.isDismissible = value;
        if (value) {
            this.dismissibleClass = `${this.type}-dismissible`;
        }
        else {
            this.dismissibleClass = '';
        }
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            if (this.dismissOnTimeout) {
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    if (!((/** @type {?} */ (this.changeDetectorRef))).destroyed) {
                        this.remove = true;
                        this.changeDetectorRef.detectChanges();
                    }
                }), this.dismissOnTimeout);
            }
            if (this.removeButtonElement) {
                this.listeners.push(this.renderer2.listen(this.removeButtonElement.nativeElement, 'click', (/**
                 * @return {?}
                 */
                () => {
                    this.remove = true;
                    this.changeDetectorRef.detectChanges();
                })));
            }
        }));
    }
    /**
     * \@method ngOnDesroy
     * @return {?}
     */
    ngOnDestroy() {
        removeListeners(this.listeners);
    }
    /**
     * [collapseStart description]
     * \@method collapseStart
     * @param {?} event [description]
     * @return {?}
     */
    collapseStart(event) {
        this.onCollapseStart.emit(event);
    }
    /**
     * [collapseDone description]
     * \@method collapseDone
     * @param {?} event [description]
     * @return {?}
     */
    collapseDone(event) {
        if (event.toState === '1') {
            this.listeners = removeListeners(this.listeners);
            this.removed = true;
            this.viewContainerRef.clear();
            this.changeDetectorRef.detectChanges();
        }
        this.onCollapseDone.emit(event);
    }
}
AlertComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-alert',
                template: "<div *ngIf=\"!removed\" [mkCollapseAnimation]=\"remove\" (mkCollapseAnimation.start)=\"collapseStart($event)\" (mkCollapseAnimation.done)=\"collapseDone($event)\">\n  <div [mkColor]=\"backgroundColor\" mkColorProperty=\"background-color\" [mkColorPrefix]=\"type\" [mkFontColor]=\"color\" [ngClass]=\"[styleClass, dismissibleClass, type]\">\n    <button *ngIf=\"isDismissible\" type=\"button\" class=\"close\" #removeButtonElement>&times;</button>\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".callout-dismissable,.callout-dismissible{padding-right:35px}.callout-dismissable .close,.callout-dismissible .close{position:relative;top:-2px;right:-21px;color:inherit}.callout .close{color:#000;opacity:.2}.callout .icon{margin-right:10px}"]
            }] }
];
/** @nocollapse */
AlertComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 },
    { type: ViewContainerRef }
];
AlertComponent.propDecorators = {
    backgroundColor: [{ type: Input }],
    callout: [{ type: Input }],
    color: [{ type: Input }],
    dismissOnTimeout: [{ type: Input }],
    _isDismissible: [{ type: Input, args: ['isDismissible',] }],
    styleClass: [{ type: Input }],
    onCollapseStart: [{ type: Output }],
    onCollapseDone: [{ type: Output }],
    removeButtonElement: [{ type: ViewChild, args: ['removeButtonElement',] }],
    containerElementRef: [{ type: ViewChild, args: ['containerElementRef', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AlertModule {
}
AlertModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, AnimationsModule, ColorModule],
                exports: [AlertComponent],
                declarations: [AlertComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class BoxContentDirective {
}
BoxContentDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'mk-box-content'
            },] }
];
/*
 *
 */
class BoxFooterDirective {
}
BoxFooterDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'mk-box-footer'
            },] }
];
/*
 *
 */
class BoxToolsDirective {
}
BoxToolsDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'mk-box-tools'
            },] }
];
/*
 *
 */
class BoxHeaderDirective {
}
BoxHeaderDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'mk-box-header'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class BoxComponent {
    /**
     * \@method constructor
     * @param {?} changeDetectorRef [description]
     * @param {?} ngZone            [description]
     * @param {?} renderer2         [description]
     */
    constructor(changeDetectorRef, ngZone, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.remove = false;
        this.listeners = [];
        this.boxColor = 'default';
        this.buttonsStyleClass = 'btn btn-box-tool';
        this.contentStyleClass = 'box-content-wrapper';
        this.footerStyleClass = 'box-footer';
        this.headerBorder = true;
        this.headerStyleClass = 'box-header';
        this.isCollapsable = true;
        this.isCollapsed = false;
        this.isRemovable = true;
        this.isSolid = false;
        this.loadingStyleClass = 'fa fa-refresh fa-spin';
        this.styleClass = 'box';
        this.onCollapseDone = new EventEmitter();
        this.onCollapseStart = new EventEmitter();
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            if (this.toggleButtonElement) {
                this.listeners.push(this.renderer2.listen(this.toggleButtonElement.nativeElement, 'click', (/**
                 * @return {?}
                 */
                () => {
                    this.isCollapsed = !this.isCollapsed;
                    this.changeDetectorRef.detectChanges();
                })));
            }
            if (this.removeButtonElement) {
                this.listeners.push(this.renderer2.listen(this.removeButtonElement.nativeElement, 'click', (/**
                 * @return {?}
                 */
                () => {
                    this.remove = true;
                    this.changeDetectorRef.detectChanges();
                })));
            }
        }));
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        removeListeners(this.listeners);
    }
    /**
     * [removedDone description]
     * \@method removedDone
     * @param {?} event [description]
     * @return {?}
     */
    removedDone(event) {
        if (event.toState === '1') {
            this.removed = true;
        }
    }
    /**
     * [collapseStart description]
     * \@method collapseStart
     * @param {?} event [description]
     * @return {?}
     */
    collapseStart(event) {
        if (event.fromState !== 'void') {
            this.isCollaping = true;
            this.onCollapseStart.emit(event);
        }
    }
    /**
     * [collapseDone description]
     * \@method collapseDone
     * @param {?} event [description]
     * @return {?}
     */
    collapseDone(event) {
        if (event.fromState !== 'void') {
            this.isCollaping = false;
            this.onCollapseDone.emit(event);
        }
    }
}
BoxComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-box',
                template: "<div *ngIf=\"!removed\" [mkColor]=\"boxColor\" mkColorProperty=\"border-color\" mkColorPrefix=\"box\" [ngClass]=\"styleClass\" [class.collapsed-box]=\"isCollapsed && !isCollaping\" [class.box-solid]=\"isSolid\" [mkCollapseAnimation]=\"remove\" (mkCollapseAnimation.done)=\"removedDone($event)\">\n  <div *ngIf=\"header || boxHeaderDirective\" [ngClass]=\"headerStyleClass\" [mkColor]=\"boxColor\" [mkColorCondition]=\"isSolid\" mkColorProperty=\"background-color\" [class.with-border]=\"headerBorder\">\n    <h3 class=\"box-title\" [mkFontColor]=\"headerColor\">\n      {{header}}\n      <ng-content select=\"mk-box-header\"></ng-content>\n    </h3>\n    <div class=\"box-tools pull-right\">\n      <ng-content select=\"mk-box-tools\"></ng-content>\n      <button *ngIf=\"isCollapsable\" type=\"button\" [ngClass]=\"buttonsStyleClass\" #toggleButtonElement>\n        <i class=\"fa\" [ngClass]=\"{'fa-plus': isCollapsed, 'fa-minus': !isCollapsed}\"></i>\n      </button>\n      <button *ngIf=\"isRemovable\" type=\"button\" [ngClass]=\"buttonsStyleClass\" #removeButtonElement>\n        <i class=\"fa fa-times\"></i>\n      </button>\n    </div>\n  </div>\n  <div [ngClass]=\"contentStyleClass\" [mkFontColor]=\"contentColor\" [mkCollapseAnimation]=\"isCollapsed\" (mkCollapseAnimation.start)=\"collapseStart($event)\" (mkCollapseAnimation.done)=\"collapseDone($event)\">\n    <div class=\"box-body\">\n      <ng-container *ngIf=\"boxHeaderDirective || boxContentDirective || boxFooterDirective || boxToolsDirective; else noDirective\">\n        <ng-content select=\"mk-box-content\"></ng-content>\n      </ng-container>\n      <ng-template #noDirective>\n        <ng-content></ng-content>\n      </ng-template>\n    </div>\n    <div *ngIf=\"footer || boxFooterDirective\" [ngClass]=\"footerStyleClass\" [mkFontColor]=\"footerColor\">\n      {{footer}}\n      <ng-content select=\"mk-box-footer\"></ng-content>\n    </div>\n  </div>\n  <div *ngIf=\"isLoading\" class=\"overlay\">\n    <i [ngClass]=\"loadingStyleClass\" [mkFontColor]=\"loadingColor\"></i>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".box.collapsed-box .box-body,.box.collapsed-box .box-footer{display:inherit}.box-solid{border:1px solid}.box-body{background-color:#fff}.box.box-solid.bg-color>.box-header{color:#fff}"]
            }] }
];
/** @nocollapse */
BoxComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 }
];
BoxComponent.propDecorators = {
    boxColor: [{ type: Input }],
    buttonsStyleClass: [{ type: Input }],
    contentStyleClass: [{ type: Input }],
    contentColor: [{ type: Input }],
    footer: [{ type: Input }],
    footerColor: [{ type: Input }],
    footerStyleClass: [{ type: Input }],
    header: [{ type: Input }],
    headerBorder: [{ type: Input }],
    headerColor: [{ type: Input }],
    headerStyleClass: [{ type: Input }],
    isCollapsable: [{ type: Input }],
    isCollapsed: [{ type: Input }],
    isLoading: [{ type: Input }],
    isRemovable: [{ type: Input }],
    isSolid: [{ type: Input }],
    loadingColor: [{ type: Input }],
    loadingStyleClass: [{ type: Input }],
    styleClass: [{ type: Input }],
    onCollapseDone: [{ type: Output }],
    onCollapseStart: [{ type: Output }],
    boxHeaderDirective: [{ type: ContentChild, args: [BoxHeaderDirective,] }],
    boxFooterDirective: [{ type: ContentChild, args: [BoxFooterDirective,] }],
    boxContentDirective: [{ type: ContentChild, args: [BoxContentDirective,] }],
    boxToolsDirective: [{ type: ContentChild, args: [BoxToolsDirective,] }],
    toggleButtonElement: [{ type: ViewChild, args: ['toggleButtonElement',] }],
    removeButtonElement: [{ type: ViewChild, args: ['removeButtonElement',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BoxModule {
}
BoxModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, AnimationsModule, ColorModule],
                exports: [BoxComponent, BoxHeaderDirective, BoxContentDirective, BoxFooterDirective, BoxToolsDirective],
                declarations: [BoxComponent, BoxHeaderDirective, BoxContentDirective, BoxFooterDirective, BoxToolsDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class BoxInfoContentDirective {
}
BoxInfoContentDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'mk-box-info-content'
            },] }
];
/*
 *
 */
class BoxInfoFooterDirective {
}
BoxInfoFooterDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'mk-box-info-footer'
            },] }
];
/*
 *
 */
class BoxInfoHeaderDirective {
}
BoxInfoHeaderDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'mk-box-info-header'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class BoxInfoComponent {
    constructor() {
        this.contentStyleClass = 'info-box-number';
        this.footerStyleClass = 'progress-description';
        this.headerStyleClass = 'info-box-text';
        this.iconColor = '#fff';
        this.iconStyleClass = 'ion ion-bag';
        this.styleClass = 'info-box';
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        if (!this.backgroundColor) {
            this.progressBarBg = this.iconBackgroundColor;
        }
    }
}
BoxInfoComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-box-info',
                template: "<div [ngClass]=\"styleClass\" [mkColor]=\"backgroundColor\" mkColorProperty=\"background-color\">\n  <span class=\"info-box-icon\" [mkColor]=\"iconBackgroundColor\" mkColorProperty=\"background-color\">\n    <i [ngClass]=\"iconStyleClass\" [mkFontColor]=\"iconColor\"></i>\n  </span>\n  <div class=\"info-box-content\">\n    <span *ngIf=\"header || boxInfoHeaderDirective\" [ngClass]=\"headerStyleClass\" [mkFontColor]=\"headerColor\">\n      {{header}}\n      <ng-content select=\"mk-box-header\"></ng-content>\n    </span>\n    <span [ngClass]=\"contentStyleClass\" [mkFontColor]=\"contentColor\">\n      <ng-container *ngIf=\"boxInfoHeaderDirective || boxInfoContentDirective || boxInfoFooterDirective; else noDirective\">\n        <ng-content select=\"mk-box-content\"></ng-content>\n      </ng-container>\n      <ng-template #noDirective>\n        <ng-content></ng-content>\n      </ng-template>\n    </span>\n    <div *ngIf=\"progressWidth\" class=\"progress\">\n      <div class=\"progress-bar\" [mkColor]=\"progressBarBg\" mkColorProperty=\"background-color\" [style.width.%]=\"progressWidth\"></div>\n    </div>\n    <span *ngIf=\"footer || boxInfoFooterDirective\" [ngClass]=\"footerStyleClass\" [mkFontColor]=\"footerColor\">\n      {{footer}}\n      <ng-content select=\"mk-box-footer\"></ng-content>\n    </span>\n  </div>\n</div>\n",
                styles: [".info-box.bg-color>.info-box-content{color:#fff}"]
            }] }
];
BoxInfoComponent.propDecorators = {
    backgroundColor: [{ type: Input }],
    contentStyleClass: [{ type: Input }],
    contentColor: [{ type: Input }],
    footer: [{ type: Input }],
    footerColor: [{ type: Input }],
    footerStyleClass: [{ type: Input }],
    header: [{ type: Input }],
    headerColor: [{ type: Input }],
    headerStyleClass: [{ type: Input }],
    iconBackgroundColor: [{ type: Input }],
    iconColor: [{ type: Input }],
    iconStyleClass: [{ type: Input }],
    progressWidth: [{ type: Input }],
    styleClass: [{ type: Input }],
    boxInfoHeaderDirective: [{ type: ContentChild, args: [BoxInfoHeaderDirective,] }],
    boxInfoFooterDirective: [{ type: ContentChild, args: [BoxInfoFooterDirective,] }],
    boxInfoContentDirective: [{ type: ContentChild, args: [BoxInfoContentDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BoxInfoModule {
}
BoxInfoModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ColorModule],
                exports: [BoxInfoComponent, BoxInfoHeaderDirective, BoxInfoContentDirective, BoxInfoFooterDirective],
                declarations: [BoxInfoComponent, BoxInfoHeaderDirective, BoxInfoContentDirective, BoxInfoFooterDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class BoxSmallFooterDirective {
}
BoxSmallFooterDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'mk-box-small-footer'
            },] }
];
/*
 *
 */
class BoxSmallHeaderDirective {
}
BoxSmallHeaderDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'mk-box-small-header'
            },] }
];
/*
 *
 */
class BoxSmallContentDirective {
}
BoxSmallContentDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'mk-box-small-content'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class BoxSmallComponent {
    constructor() {
        this.contentStyleClass = 'small-box-content';
        this.footerStyleClass = 'small-box-footer';
        this.headerStyleClass = 'small-box-header';
        this.iconStyleClass = 'ion ion-bag';
        this.styleClass = 'small-box';
    }
}
BoxSmallComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-box-small',
                template: "<div [ngClass]=\"styleClass\" [mkColor]=\"backgroundColor\" mkColorProperty=\"background-color\">\n  <div class=\"inner\">\n    <h3 *ngIf=\"header || boxSmallHeaderDirective\" [ngClass]=\"headerStyleClass\" [mkFontColor]=\"headerColor\">\n      {{header}}\n      <ng-content select=\"mk-box-small-header\"></ng-content>\n    </h3>\n    <p [ngClass]=\"contentStyleClass\" [mkFontColor]=\"contentColor\">\n      <ng-container *ngIf=\"boxSmallHeaderDirective || boxSmallContentDirective || boxSmallFooterDirective; else noDirective\">\n        <ng-content select=\"mk-box-small-content\"></ng-content>\n      </ng-container>\n      <ng-template #noDirective>\n        <ng-content></ng-content>\n      </ng-template>\n    </p>\n  </div>\n  <div *ngIf=\"iconStyleClass\" class=\"icon\">\n    <i [ngClass]=\"iconStyleClass\" [mkFontColor]=\"iconColor\"></i>\n  </div>\n  <span *ngIf=\"footer || boxSmallFooterDirective\" [ngClass]=\"footerStyleClass\" [mkFontColor]=\"footerColor\">\n    {{footer}}\n    <ng-content select=\"mk-box-small-footer\"></ng-content>\n  </span>\n</div>\n",
                styles: [".small-box.bg-color{color:#fff}/deep/ .small-box-footer:hover{cursor:pointer}/deep/ .small-box-footer a{color:rgba(255,255,255,.8)}/deep/ .small-box-footer:hover a{color:#fff}"]
            }] }
];
BoxSmallComponent.propDecorators = {
    backgroundColor: [{ type: Input }],
    contentColor: [{ type: Input }],
    contentStyleClass: [{ type: Input }],
    footer: [{ type: Input }],
    footerColor: [{ type: Input }],
    footerStyleClass: [{ type: Input }],
    header: [{ type: Input }],
    headerColor: [{ type: Input }],
    headerStyleClass: [{ type: Input }],
    iconColor: [{ type: Input }],
    iconStyleClass: [{ type: Input }],
    styleClass: [{ type: Input }],
    boxSmallHeaderDirective: [{ type: ContentChild, args: [BoxSmallHeaderDirective,] }],
    boxSmallFooterDirective: [{ type: ContentChild, args: [BoxSmallFooterDirective,] }],
    boxSmallContentDirective: [{ type: ContentChild, args: [BoxSmallContentDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BoxSmallModule {
}
BoxSmallModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ColorModule],
                exports: [BoxSmallComponent, BoxSmallHeaderDirective, BoxSmallContentDirective, BoxSmallFooterDirective],
                declarations: [BoxSmallComponent, BoxSmallHeaderDirective, BoxSmallContentDirective, BoxSmallFooterDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class DropdownToggleComponent {
}
DropdownToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-dropdown-toggle',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
DropdownToggleComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }],
    toggleElement: [{ type: ContentChild, args: ['toggleElement',] }]
};
/*
 *
 */
class DropdownMenuComponent {
}
DropdownMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-dropdown-menu',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
DropdownMenuComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }]
};
/*
 *
 */
class DropdownComponent {
    /**
     * \@method constructor
     * @param {?} changeDetectorRef [description]
     * @param {?} elementRef [description]
     * @param {?} ngZone [description]
     * @param {?} renderer2 [description]
     */
    constructor(changeDetectorRef, elementRef, ngZone, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.listeners = [];
        this.buttonStyleClass = 'btn dropdown-toggle';
        this.buttonBackgroudColor = 'default';
        this.contentStyleClass = 'dropdown-menu';
        this.isCollapsed = true;
        this.isWrapper = true;
        this.styleClass = 'dropdown';
        this.onCollapseStart = new EventEmitter();
        this.onCollapseDone = new EventEmitter();
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const toggleNativeElement = this.dropdownToggleComponent && this.dropdownToggleComponent.toggleElement ?
            this.dropdownToggleComponent.toggleElement.nativeElement : this.toggleElement ?
            this.toggleElement : this.defaultToggleElement ?
            this.defaultToggleElement.nativeElement : null;
        if (toggleNativeElement) {
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this.listeners.push(this.renderer2.listen(toggleNativeElement, 'click', (/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    this.toggleDropdown(event);
                    this.changeDetectorRef.detectChanges();
                })));
            }));
        }
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        this.unBindDocumentClickListener();
        removeListeners(this.listeners);
    }
    /**
     * [toggle description]
     * \@method toggle
     * @param {?} event [description]
     * @return {?}
     */
    toggleDropdown(event) {
        event.preventDefault();
        this.isCollapsed = !this.isCollapsed;
        if (!this.isCollapsed) {
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.bindDocumentClickListener();
                }));
            }));
        }
        else {
            this.unBindDocumentClickListener();
        }
    }
    /**
     * [collapseStart description]
     * \@method collapseStart
     * @param {?} event [description]
     * @return {?}
     */
    collapseStart(event) {
        this.onCollapseStart.emit(event);
    }
    /**
     * [collapseDone description]
     * \@method collapseDone
     * @param {?} event [description]
     * @return {?}
     */
    collapseDone(event) {
        this.onCollapseStart.emit(event);
    }
    /**
     * [bindDocumentClickListener description]
     * \@method bindDocumentClickListener
     * @private
     * @return {?}
     */
    bindDocumentClickListener() {
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.documentClickListener = this.renderer2.listen('document', 'click', (/**
             * @return {?}
             */
            () => {
                if (!this.isCollapsed) {
                    this.isCollapsed = true;
                    this.unBindDocumentClickListener();
                    this.changeDetectorRef.detectChanges();
                }
            }));
        }));
    }
    /**
     * [unBindDocumentClickListener description]
     * \@method unBindDocumentClickListener
     * @private
     * @return {?}
     */
    unBindDocumentClickListener() {
        if (this.documentClickListener) {
            this.documentClickListener();
        }
    }
}
DropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-dropdown, [mk-dropdown]',
                template: "<ng-template #innerTemplate>\n  <ng-container *ngIf=\"this.dropdownToggleComponent && this.dropdownToggleComponent.toggleElement; else noToggleElement\" [ngTemplateOutlet]=\"dropdownToggleComponent.templateRef\"></ng-container>\n  <ng-template #noToggleElement>\n    <button *ngIf=\"toggleText || dropdownToggleComponent\" [mkColor]=\"buttonBackgroudColor\" mkColorProperty=\"background-color\" mkColorPrefix=\"btn\" [ngClass]=\"buttonStyleClass\" #toggleElement>\n      {{toggleText}}\n      <ng-container [ngTemplateOutlet]=\"dropdownToggleComponent?.templateRef\"></ng-container>\n    </button>\n  </ng-template>\n  <ul [ngClass]=\"contentStyleClass\" [mkCollapseAnimation]=\"isCollapsed\" (mkCollapseAnimation.start)=\"collapseStart($event)\" (mkCollapseAnimation.done)=\"collapseDone($event)\">\n    <ng-container *ngIf=\"dropdownMenuComponent; else noDropdownMenuComponent\" [ngTemplateOutlet]=\"dropdownMenuComponent.templateRef\"></ng-container>\n    <ng-template #noDropdownMenuComponent>\n      <ng-content></ng-content>\n    </ng-template>\n  </ul>\n</ng-template>\n\n<div *ngIf=\"isWrapper; else noWrapper\" [ngClass]=\"styleClass\">\n  <ng-container *ngTemplateOutlet=\"innerTemplate\"></ng-container>\n</div>\n\n<ng-template #noWrapper>\n  <ng-container *ngTemplateOutlet=\"innerTemplate\"></ng-container>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".dropdown-menu{display:block}.dropdown-menu.collapsing:not(.un-collapse){transition-property:height,padding-top,padding-bottom;padding-top:0;padding-bottom:0}"]
            }] }
];
/** @nocollapse */
DropdownComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 }
];
DropdownComponent.propDecorators = {
    buttonStyleClass: [{ type: Input }],
    buttonBackgroudColor: [{ type: Input }],
    contentStyleClass: [{ type: Input }],
    isCollapsed: [{ type: Input }],
    isWrapper: [{ type: Input }],
    styleClass: [{ type: Input }],
    toggleElement: [{ type: Input }],
    toggleText: [{ type: Input }],
    onCollapseStart: [{ type: Output }],
    onCollapseDone: [{ type: Output }],
    dropdownToggleComponent: [{ type: ContentChild, args: [DropdownToggleComponent,] }],
    dropdownMenuComponent: [{ type: ContentChild, args: [DropdownMenuComponent,] }],
    defaultToggleElement: [{ type: ViewChild, args: ['toggleElement',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DropdownModule {
}
DropdownModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, AnimationsModule, ColorModule],
                exports: [DropdownComponent, DropdownToggleComponent, DropdownMenuComponent],
                declarations: [DropdownComponent, DropdownToggleComponent, DropdownMenuComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class InputGroupLabelDirective {
}
InputGroupLabelDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'mk-input-group-label'
            },] }
];
/*
 *
 */
class InputGroupAddonLeftDirective {
}
InputGroupAddonLeftDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'mk-input-group-addon-left'
            },] }
];
/*
 *
 */
class InputGroupAddonRightDirective {
}
InputGroupAddonRightDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'mk-input-group-addon-right'
            },] }
];
/*
 *
 */
class InputGroupContentDirective {
}
InputGroupContentDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'mk-input-group-content'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class ClassService {
    /**
     * @param {?} elementRef
     * @param {?} renderer2
     */
    constructor(elementRef, renderer2) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.currentClasses = [];
    }
    /**
     * @param {?} cssClasses
     * @return {?}
     */
    applyClasses(cssClasses) {
        if (typeof cssClasses === 'string') {
            cssClasses = cssClasses.split(' ');
        }
        // Remove only classes that are not in cssClasses
        /** @type {?} */
        const classesToRemove = this.currentClasses.filter((/**
         * @param {?} x
         * @return {?}
         */
        x => cssClasses.indexOf(x) === -1));
        classesToRemove.forEach((/**
         * @param {?} cssClasse
         * @return {?}
         */
        cssClasse => {
            if (cssClasse) {
                this.renderer2.removeClass(this.elementRef.nativeElement, cssClasse);
            }
        }));
        // Add only classes that are not in currentClasses
        /** @type {?} */
        const classesToAdd = cssClasses.filter((/**
         * @param {?} x
         * @return {?}
         */
        x => this.currentClasses.indexOf(x) === -1));
        classesToAdd.forEach((/**
         * @param {?} cssClasse
         * @return {?}
         */
        cssClasse => {
            if (cssClasse) {
                this.renderer2.addClass(this.elementRef.nativeElement, cssClasse);
            }
        }));
        // Update current classes for futur updates
        this.currentClasses = [...cssClasses];
    }
}
ClassService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ClassService.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @TODO onFocus Color
class InputTextDirective {
    /**
     * \@method constructor
     * @param {?} elementRef   [description]
     * @param {?} renderer2    [description]
     * @param {?} ngControl    [description]
     * @param {?} colorService [description]
     * @param {?} classService [description]
     */
    constructor(elementRef, renderer2, ngControl, colorService, classService) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.ngControl = ngControl;
        this.colorService = colorService;
        this.classService = classService;
        this.defaultClass = 'form-control';
        this._onKeyUp = new Subject();
        this.onKeyup = this._onKeyUp.asObservable();
    }
    /**
     * @param {?} color
     * @return {?}
     */
    set borderColor(color) {
        this.colorService.setBackgroundColor(color, true, 'border-color', null);
    }
    /**
     * @param {?} className
     * @return {?}
     */
    set class(className) {
        this.isSetClass = true;
        this.classService.applyClasses(className);
    }
    /**
     * @param {?} color
     * @return {?}
     */
    set color(color) {
        this.colorService.setFontColor(color);
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        if (!this.isSetClass) {
            this.classService.applyClasses(this.defaultClass);
        }
    }
    /**
     * @return {?}
     */
    keyUpListener() {
        this._onKeyUp.next(this.ngControl);
    }
}
InputTextDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mkInputText]',
                providers: [ColorService, ClassService]
            },] }
];
/** @nocollapse */
InputTextDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgControl },
    { type: ColorService },
    { type: ClassService }
];
InputTextDirective.propDecorators = {
    borderColor: [{ type: Input }],
    class: [{ type: Input }],
    color: [{ type: Input }],
    keyUpListener: [{ type: HostListener, args: ['keyup',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class InputGroupComponent {
    constructor() {
        this.subscriptions = [];
        this.inputColor = 'default';
        this.inputErrorColor = 'danger';
        this.inputValidColor = 'success';
        this.wrapperClasses = 'form-group';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.subscriptions.push(this.inputTextDirective.onKeyup.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            if (value.invalid) {
                this.currentColor = this.inputErrorColor;
                this.currentFontColor = this.inputErrorFontColor;
            }
            else if (!value.invalid) {
                this.currentColor = this.inputValidColor;
                this.currentFontColor = this.inputValidFontColor;
            }
            else {
                this.currentColor = this.inputColor;
                this.currentFontColor = this.inputFontColor;
            }
        })));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        removeSubscriptions(this.subscriptions);
    }
}
InputGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-input-group',
                template: "<div [ngClass]=\"wrapperClasses\" [mkColor]=\"currentColor || inputColor\" mkColorPrefix=\"has\">\n  <label *ngIf=\"label || inputGroupLabelDirective\">\n    {{label}}\n    <ng-content select=\"mk-input-group-label\"></ng-content>\n  </label>\n  <div *ngIf=\"addonLeft || inputGroupAddonLeftDirective || addonRight || inputGroupAddonRightDirective; else noAddon\" class=\"input-group\">\n    <span *ngIf=\"addonLeft || inputGroupAddonLeftDirective\" class=\"input-group-addon\">\n      {{addonLeft}}\n      <ng-content select=\"mk-input-group-addon-left\"></ng-content>\n    </span>\n    <ng-content select=\"mk-input-group-content\"></ng-content>\n    <span *ngIf=\"addonRight || inputGroupAddonRightDirective\" class=\"input-group-addon\">\n      {{addonRight}}\n      <ng-content select=\"mk-input-group-addon-right\"></ng-content>\n    </span>\n  </div>\n  <ng-template #noAddon><ng-content select=\"mk-input-group-content\"></ng-content></ng-template>\n</div>\n"
            }] }
];
InputGroupComponent.propDecorators = {
    addonLeft: [{ type: Input }],
    addonRight: [{ type: Input }],
    inputColor: [{ type: Input }],
    inputFontColor: [{ type: Input }],
    inputErrorColor: [{ type: Input }],
    inputErrorFontColor: [{ type: Input }],
    inputValidColor: [{ type: Input }],
    inputValidFontColor: [{ type: Input }],
    label: [{ type: Input }],
    wrapperClasses: [{ type: Input }],
    inputGroupLabelDirective: [{ type: ContentChild, args: [InputGroupLabelDirective,] }],
    inputGroupAddonLeftDirective: [{ type: ContentChild, args: [InputGroupAddonLeftDirective,] }],
    inputGroupAddonRightDirective: [{ type: ContentChild, args: [InputGroupAddonRightDirective,] }],
    inputGroupContentDirective: [{ type: ContentChild, args: [InputGroupContentDirective,] }],
    inputTextDirective: [{ type: ContentChild, args: [InputTextDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InputGroupModule {
}
InputGroupModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ColorModule,
                    FormsModule
                ],
                exports: [InputGroupComponent, InputGroupLabelDirective, InputGroupAddonLeftDirective,
                    InputGroupAddonRightDirective, InputGroupContentDirective],
                declarations: [InputGroupComponent, InputGroupLabelDirective, InputGroupAddonLeftDirective,
                    InputGroupAddonRightDirective, InputGroupContentDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InputTextModule {
}
InputTextModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ColorModule,
                    FormsModule
                ],
                exports: [InputTextDirective],
                declarations: [InputTextDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *
 */
class TabToggleDirective {
    /**
     * \@method constructor
     * @param {?} elementRef [description]
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
TabToggleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mkTabToggle]'
            },] }
];
/** @nocollapse */
TabToggleDirective.ctorParameters = () => [
    { type: ElementRef }
];
TabToggleDirective.propDecorators = {
    tabComponent: [{ type: Input, args: ['mkTabToggle',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @TODO Vertical tabs
/*
 *
 */
class TabHeaderComponent {
}
TabHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-tab-header',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
TabHeaderComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }]
};
/*
 *
 */
class TabContentComponent {
}
TabContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-tab-content',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
TabContentComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }]
};
/*
 *
 */
class TabComponent {
    constructor() {
        this.isActive = false;
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        if (this.tabContentComponent) {
            this.contentTemplateRef = this.tabContentComponent.templateRef;
        }
        else {
            this.contentTemplateRef = this.templateRef;
        }
    }
}
TabComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-tab',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
TabComponent.propDecorators = {
    header: [{ type: Input }],
    isDisabled: [{ type: Input }],
    tabColor: [{ type: Input }],
    templateRef: [{ type: ViewChild, args: ['templateRef',] }],
    tabHeaderComponent: [{ type: ContentChild, args: [TabHeaderComponent,] }],
    tabContentComponent: [{ type: ContentChild, args: [TabContentComponent,] }]
};
/*
 *
 */
class TabsHeaderComponent {
}
TabsHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-tabs-header',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
TabsHeaderComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }]
};
/*
 *
 */
class TabsComponent {
    /**
     * \@method constructor
     * @param {?} changeDetectorRef [description]
     * @param {?} ngZone            [description]
     * @param {?} renderer2         [description]
     */
    constructor(changeDetectorRef, ngZone, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.listeners = [];
        this.subscriptions = [];
        this.headerStyleClass = 'header pull-left';
        this.navStyleClass = 'nav nav-tabs';
        this.contentStyleClass = 'tab-content';
        this.styleClass = 'nav-tabs-custom';
        this.onClose = new EventEmitter();
        this.onOpen = new EventEmitter();
    }
    /**
     * @param {?} index
     * @return {?}
     */
    set activeTabIndex(index) {
        this.activatedTabIndex = index;
        this.changeDetectorRef.detectChanges();
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterContentInit() {
        // Set tab index on load.
        this.setTabIndex();
        // Update tab index if tabs is updated.
        this.subscriptions.push(this.tabs.changes.subscribe((/**
         * @return {?}
         */
        () => {
            this.setTabIndex();
        })));
        // Open tab on load.
        this.openTabIndex();
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        // Set tab toggles on load.
        this.setTabsToggle();
        // Update tab toggles if tabs is updated.
        this.subscriptions.push(this.tabToggleDirectives.changes.subscribe((/**
         * @return {?}
         */
        () => {
            this.setTabsToggle();
        })));
    }
    /**
     * \@method ngOnChanges
     * @param {?} changes [description]
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.activeTabIndex) {
            this.openTabIndex();
        }
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        removeListeners(this.listeners);
        removeSubscriptions(this.subscriptions);
    }
    /**
     * [toggleTab description]
     * \@method toggleTab
     * @return {?}
     */
    openTabIndex() {
        if (this.tabs) {
            this.tabs.forEach((/**
             * @param {?} tab
             * @return {?}
             */
            (tab) => {
                if (this.activatedTabIndex === tab.index || (this.activatedTabIndex === undefined && tab.index === 0)) {
                    tab.isActive = true;
                    this.onOpen.emit({ index: tab.index });
                    this.changeDetectorRef.detectChanges();
                }
                else if (tab.isActive) {
                    tab.isActive = false;
                    this.onClose.emit({ index: tab.index });
                    this.changeDetectorRef.detectChanges();
                }
            }));
        }
    }
    /**
     * [openTab description]
     * \@method openTab
     * @param {?} event     [description]
     * @param {?} tabToOpen [description]
     * @return {?}
     */
    openTab(event, tabToOpen) {
        event.preventDefault();
        tabToOpen.isActive = true;
        this.onOpen.emit({ event, index: tabToOpen.index });
        this.tabs.forEach((/**
         * @param {?} tab
         * @return {?}
         */
        (tab) => {
            if (tab.isActive && tabToOpen !== tab) {
                tab.isActive = false;
                this.onClose.emit({ event, index: tab.index });
            }
        }));
    }
    /**
     * [setTabIndex description]
     * \@method setTabIndex
     * @private
     * @return {?}
     */
    setTabIndex() {
        this.tabs.forEach((/**
         * @param {?} tab
         * @param {?} index
         * @return {?}
         */
        (tab, index) => {
            tab.index = index;
        }));
        this.changeDetectorRef.detectChanges();
    }
    /**
     * [setTabsToggle description]
     * \@method setTabsToggle
     * @private
     * @return {?}
     */
    setTabsToggle() {
        this.listeners = removeListeners(this.listeners);
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.tabToggleDirectives.forEach((/**
             * @param {?} tabToggle
             * @return {?}
             */
            (tabToggle) => {
                this.listeners.push(this.renderer2.listen(tabToggle.elementRef.nativeElement, 'click', (/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    this.openTab(event, tabToggle.tabComponent);
                    this.changeDetectorRef.detectChanges();
                })));
            }));
        }));
    }
}
TabsComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-tabs',
                template: "<div [ngClass]=\"styleClass\">\n  <ul [ngClass]=\"navStyleClass\" [class.pull-right]=\"header || tabsHeaderComponent\">\n    <li *ngFor=\"let tab of tabs\" [class.active]=\"tab.isActive\" [mkColor]=\"tab.tabColor || tabsColor\" mkColorProperty=\"border-top-color\">\n      <a *ngIf=\"!tab.isDisabled\" [mkTabToggle]=\"tab\" href=\"#\">\n        {{tab.header}}\n        <ng-template *ngIf=\"!tab.header\" [ngTemplateOutlet]=\"tab.tabHeaderComponent?.templateRef\"></ng-template>\n      </a>\n      <ng-template [ngIf]=\"tab.isDisabled\">\n        {{tab.header}}\n        <ng-template *ngIf=\"!tab.header\" [ngTemplateOutlet]=\"tab.tabHeaderComponent.templateRef\"></ng-template>\n      </ng-template>\n    </li>\n    <li *ngIf=\"tabsHeaderComponent || header\" [ngClass]=\"headerStyleClass\">\n      {{header}}\n      <ng-template *ngIf=\"!header\" [ngTemplateOutlet]=\"tabsHeaderComponent.templateRef\"></ng-template>\n    </li>\n  </ul>\n  <div [ngClass]=\"contentStyleClass\">\n    <div *ngFor=\"let tab of tabs\" class=\"tab-pane\" [class.active]=\"tab.isActive\">\n      <ng-template [ngTemplateOutlet]=\"tab.contentTemplateRef\"></ng-template>\n    </div>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".nav-tabs-custom>.nav-tabs>li{border-top-width:0}.nav-tabs-custom>.nav-tabs>li.active{border-top-width:3px}"]
            }] }
];
/** @nocollapse */
TabsComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 }
];
TabsComponent.propDecorators = {
    activeTabIndex: [{ type: Input }],
    header: [{ type: Input }],
    headerStyleClass: [{ type: Input }],
    navStyleClass: [{ type: Input }],
    contentStyleClass: [{ type: Input }],
    styleClass: [{ type: Input }],
    tabsColor: [{ type: Input }],
    onClose: [{ type: Output }],
    onOpen: [{ type: Output }],
    tabsHeaderComponent: [{ type: ContentChild, args: [TabsHeaderComponent,] }],
    tabs: [{ type: ContentChildren, args: [TabComponent,] }],
    tabToggleDirectives: [{ type: ViewChildren, args: [TabToggleDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabsModule {
}
TabsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ColorModule],
                exports: [TabsComponent, TabsHeaderComponent, TabComponent, TabHeaderComponent, TabContentComponent],
                declarations: [TabToggleDirective, TabsComponent, TabsHeaderComponent, TabComponent, TabHeaderComponent, TabContentComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { LayoutModule, LayoutService, LayoutStore, AccordionModule, AlertModule, BoxModule, BoxInfoModule, BoxSmallModule, BreadcrumbsModule, DropdownModule, InputGroupModule, InputTextModule, TabsModule, AccordionComponent as bi, AccordionContentComponent as bh, AccordionGroupComponent as bj, AccordionHeaderComponent as bg, AccordionToggleDirective as bk, AlertComponent as bl, CollapseAnimationDirective as r, AnimationsModule as q, BoxInfoComponent as br, BoxInfoContentDirective as bs, BoxInfoFooterDirective as bt, BoxInfoHeaderDirective as bu, BoxSmallComponent as bv, BoxSmallContentDirective as by, BoxSmallFooterDirective as bw, BoxSmallHeaderDirective as bx, BoxComponent as bm, BoxContentDirective as bn, BoxFooterDirective as bo, BoxHeaderDirective as bq, BoxToolsDirective as bp, BreadcrumbsComponent as b, BackgroundColorDirective as bd, ColorDirective as be, ColorModule as bc, ColorService as bf, DropdownComponent as cb, DropdownMenuComponent as ca, DropdownToggleComponent as bz, InputGroupComponent as cc, InputGroupAddonLeftDirective as ce, InputGroupAddonRightDirective as cf, InputGroupContentDirective as cg, InputGroupLabelDirective as cd, InputTextDirective as ch, ContentComponent as d, ContentModule as a, FooterComponent as k, FooterLeftComponent as i, FooterRightComponent as j, FooterModule as h, FooterService as g, HeaderComponent as o, HeaderLogoComponent as m, HeaderLogoMiniComponent as n, HeaderModule as l, HeaderService as f, LayoutConfigToken as z, layoutProvider as bb, layoutStoreFactory as ba, SidebarLeftComponent as s, SidebarLeftToggleDirective as t, SidebarLeftModule as p, SidebarRightComponent as w, SidebarRightModule as v, SidebarRightService as e, WrapperComponent as y, WrapperModule as x, WrapperService as u, ClassService as ci, RoutingService as c, TabComponent as cl, TabContentComponent as ck, TabHeaderComponent as cj, TabsComponent as cn, TabsHeaderComponent as cm, TabToggleDirective as co };

//# sourceMappingURL=angular-admin-lte.js.map